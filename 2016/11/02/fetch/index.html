<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Fetch进阶指南 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="fetch async await mode promise progress abort">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Fetch进阶指南">
<meta property="og:url" content="http://louiszhai.github.io/2016/11/02/fetch/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="fetch async await mode promise progress abort">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax07.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax08.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax28.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax11.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax09.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax10.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax12.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax13.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax14.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax22.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax15.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/ajax16.png">
<meta property="og:updated_time" content="2020-07-04T05:48:04.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fetch进阶指南">
<meta name="twitter:description" content="fetch async await mode promise progress abort">
<meta name="twitter:image" content="http://louiszhai.github.io/docImages/ajax07.png">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div id="container">
    <div class="left-col">
        <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">路易斯</a></h1>
		</hgroup>

		
		<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 16.67px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/JavaScript-Canvas/" style="font-size: 10px;">JavaScript Canvas</a> <a href="/tags/JavaScript-Chrome-Extension/" style="font-size: 10px;">JavaScript Chrome-Extension</a> <a href="/tags/Tool/" style="font-size: 16.67px;">Tool</a> <a href="/tags/Web/" style="font-size: 16.67px;">Web</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhangxinxu.com/wordpress/category/js/">张鑫旭-鑫空间-鑫生活</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://evanyou.me/">尤雨溪主页</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
        <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">路易斯</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">路易斯</h1>
			</hgroup>
			
			<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

        <div class="body-wrap"><article id="post-fetch" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/02/fetch/" class="article-date">
  	<time datetime="2016-11-02T04:48:08.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fetch进阶指南
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#导读"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-text">Fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#尝试一个fetch"><span class="toc-text">尝试一个fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise特性"><span class="toc-text">Promise特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response-type"><span class="toc-text">response type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mode"><span class="toc-text">mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#header"><span class="toc-text">header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#post"><span class="toc-text">post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#credentials"><span class="toc-text">credentials</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch"><span class="toc-text">catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache"><span class="toc-text">cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await"><span class="toc-text">async/await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么是async-await"><span class="toc-text">为什么是async/await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#async-await语法"><span class="toc-text">async/await语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何试运行async-await"><span class="toc-text">如何试运行async/await</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何弥补Fetch的不足"><span class="toc-text">如何弥补Fetch的不足</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fetch-jsonp"><span class="toc-text">fetch-jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort"><span class="toc-text">abort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeout"><span class="toc-text">timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#progress"><span class="toc-text">progress</span></a></li></ol></li></ol>
</div>
      
        <h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>对于前端来说，Axios应该不陌生，自从尤大推荐后，Axios几乎成了前端必备工具库，Axios的体积也与日俱增，当前最新版本已经达到了14k的size，这样的大小，在sdk中引用是不太合适的，而XMLHttpRequest又过于原始，还不支持promise，需要进一步封装。那么有没有简单便捷的ajax API呢？它就是Fetch。</p>
<p>Fetch 是 web异步通信的未来. 从chrome42, Firefox39, Opera29, EdgeHTML14(并非Edge版本)起, fetch就已经被支持了. 其中chrome42~45版本, fetch对中文支持有问题, 建议从chrome46起使用fetch. 传送门: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=511289" target="_blank" rel="external">fetch中文乱码</a> .</p>
<a id="more"></a>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>先过一遍Fetch原生支持率.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax07.png" alt=""><br><img src="http://louiszhai.github.io/docImages/ajax08.png" alt=""></p>
<p>以下是2020年7月4日更新的 Fetch 兼容性统计，除了 IE 系列，Fetch 兼容性基本没什么大问题。</p>
<p><img src="http://louiszhai.github.io/docImages/ajax28.png" alt=""></p>
<p>可见要想在IE8/9/10/11中使用fetch还是有些犯难的,毕竟它连 Promise 都不支持, 更别说fetch了. 别急, 这里有polyfill(垫片). </p>
<ul>
<li>es5 的 polyfill — <a href="https://github.com/es-shims/es5-shim" target="_blank" rel="external"><code>es5-shim, es5-sham</code></a> .</li>
<li>Promise 的 polyfill — <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external"><code>es6-promise</code></a> .</li>
<li>fetch 的 polyfill — <a href="https://github.com/camsong/fetch-ie8" target="_blank" rel="external"><code>fetch-ie8</code></a> .</li>
</ul>
<p>由于IE8基于ES3, IE9、IE10、IE11基于ES5，但支持不完全. 因此IE8+浏览器, 建议依次装载上述垫片.</p>
<h4 id="尝试一个fetch"><a href="#尝试一个fetch" class="headerlink" title="尝试一个fetch"></a>尝试一个fetch</h4><p>先来看一个简单的fetch.</p>
<pre><code class="js">var word = &#39;123&#39;,
    url = &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#39;+word+&#39;&amp;json=1&amp;p=3&#39;;
fetch(url,{mode: &quot;no-cors&quot;}).then(function(response) {
  return response;
}).then(function(data) {
  console.log(data);
}).catch(function(e) {
  console.log(&quot;Oops, error&quot;);
});
</code></pre>
<p>fetch执行后返回一个 <code>Promise</code> 对象, 执行成功后, 成功打印出 <code>Response</code> 对象.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax11.png" alt="response headers"></p>
<p>该fetch可以在任何域名的网站直接运行, 且能正常返回百度搜索的建议词条. 以下是常规输入时的是界面截图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax09.png" alt="response headers"></p>
<p>以下是刚才fetch到的部分数据. 其中key name 为”s”的字段的value就是以上的建议词条.(由于有高亮词条”12306”, 最后一条数据”12366”被顶下去了, 故上面截图上看不到)</p>
<p><img src="http://louiszhai.github.io/docImages/ajax10.png" alt="response headers"></p>
<p>看完栗子过后, 就要动真格了. 下面就来扒下 Fetch.</p>
<h4 id="Promise特性"><a href="#Promise特性" class="headerlink" title="Promise特性"></a>Promise特性</h4><p>fetch方法返回一个Promise对象, 根据 <code>Promise Api</code> 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch. 一但then中的语句出现错误, 也将跳到catch中.</p>
<p>Promise若有疑问, 请阅读 <a href="https://www.promisejs.org/" target="_blank" rel="external">Promises</a> .</p>
<p>① 我们不妨在 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台运行以下代码.</p>
<pre><code class="js">var word = &#39;123&#39;,
    url = &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#39;+word+&#39;&amp;json=1&amp;p=3&#39;;
fetch(url).then(function(response){
  console.log(&#39;第一次进入then...&#39;);
  if(response.status&gt;=200 &amp;&amp; response.status&lt;300){
    console.log(&#39;Content-Type: &#39; + response.headers.get(&#39;Content-Type&#39;));
    console.log(&#39;Date: &#39; + response.headers.get(&#39;Date&#39;));
    console.log(&#39;status: &#39; + response.status);
    console.log(&#39;statusText: &#39; + response.statusText);
    console.log(&#39;type: &#39; + response.type);
    console.log(&#39;url: &#39; + response.url);
    return Promise.resolve(response);
  }else{
    return Promise.reject(new Error(response.statusText));
  }
}).then(function(data){
  console.log(&#39;第二次进入then...&#39;);
  console.log(data);
}).catch(function(e){
  console.log(&#39;抛出的错误如下:&#39;);
  console.log(e);
});
</code></pre>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax12.png" alt="fetch then"></p>
<p>② 我们不妨在非 <a href="https://sp0.baidu.com" target="_blank" rel="external">https://sp0.baidu.com</a> 域名的网页控制台再次运行以上代码.(别忘了给fetch的第二参数传递{mode: “no-cors”})</p>
<p>运行截图如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax13.png" alt="fetch catch"></p>
<p>由于第一次进入then分支后, 返回了否定结果的 Promise.reject 对象. 因此代码进入到catch分支, 抛出了错误. 此时, 上述 <code>response.type</code> 为 <code>opaque</code> .</p>
<h4 id="response-type"><a href="#response-type" class="headerlink" title="response type"></a>response type</h4><p>一个fetch请求的响应类型(response.type)为如下三种之一:</p>
<ul>
<li>basic</li>
<li>cors</li>
<li>opaque</li>
</ul>
<p>如上情景①, 同域下, 响应类型为 “basic”.</p>
<p>如上情景②中, 跨域下, 服务器没有返回CORS响应头, 响应类型为 “opaque”. 此时我们几乎不能查看任何有价值的信息, 比如不能查看response, status, url等等等等.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax14.png" alt="fetch type"></p>
<p>同样是跨域下, 如果服务器返回了CORS响应头, 那么响应类型将为 “cors”. 此时响应头中除 <code>Cache-Control</code> , <code>Content-Language</code> , <code>Content-Type</code> , <code>Expores</code> , <code>Last-Modified</code> 和 <code>Progma</code> 之外的字段都不可见.</p>
<p>注意: 无论是同域还是跨域, 以上 fetch 请求都到达了服务器.</p>
<h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>fetch可以设置不同的模式使得请求有效. 模式可在fetch方法的第二个参数对象中定义.</p>
<pre><code class="js">fetch(url, {mode: &#39;cors&#39;});
</code></pre>
<p>可定义的模式如下:</p>
<ul>
<li>same-origin: 表示同域下可请求成功; 反之, 浏览器将拒绝发送本次fetch, 同时抛出错误 “TypeError: Failed to fetch(…)”.</li>
<li>cors: 表示同域和带有CORS响应头的跨域下可请求成功. 其他请求将被拒绝.</li>
<li>cors-with-forced-preflight: 表示在发出请求前, 将执行preflight检查.</li>
<li>no-cors: 常用于跨域请求不带CORS响应头场景, 此时响应类型为 “opaque”.</li>
</ul>
<p>除此之外, 还有两种不太常用的mode类型, 分别是 <code>navigate</code> , <code>websocket</code> , 它们是 <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="external">HTML标准</a> 中特殊的值, 这里不做详细介绍.</p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>fetch获取http响应头非常easy. 如下:</p>
<pre><code class="js">fetch(url).then(function(response) { 
    console.log(response.headers.get(&#39;Content-Type&#39;));
});
</code></pre>
<p>设置http请求头也一样简单.</p>
<pre><code class="js">var headers = new Headers();
headers.append(&quot;Content-Type&quot;, &quot;text/html&quot;);
fetch(url,{
  headers: headers
});
</code></pre>
<p>header的内容也是可以被检索的.</p>
<pre><code class="js">var header = new Headers({
  &quot;Content-Type&quot;: &quot;text/plain&quot;
});
console.log(header.has(&quot;Content-Type&quot;)); //true
console.log(header.has(&quot;Content-Length&quot;)); //false
</code></pre>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>在fetch中发送post请求, 同样可以在fetch方法的第二个参数对象中设置.</p>
<pre><code class="js">var headers = new Headers();
headers.append(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);
fetch(url, {
  method: &#39;post&#39;,
  headers: headers,
  body: JSON.stringify({
    date: &#39;2016-10-08&#39;,
    time: &#39;15:16:00&#39;
  })
});
</code></pre>
<h4 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h4><p>跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.</p>
<pre><code class="js">fetch(url,{
  credentials: &#39;include&#39;
});
</code></pre>
<p>除此之外, credentials 还可以取以下值:</p>
<ul>
<li>omit: 缺省值, 默认为该值.</li>
<li>same-origin: 同源, 表示同域请求才发送cookie.</li>
</ul>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>同 XMLHttpRequest 一样, 无论服务器返回什么样的状态码(chrome中除407之外的其他状态码), 它们都不会进入到错误捕获里. 也就是说, 此时, XMLHttpRequest 实例不会触发 <code>onerror</code> 事件回调, fetch 不会触发 reject. <strong>通常只在网络出现问题时或者ERR_CONNECTION_RESET时, 它们才会进入到相应的错误捕获里.</strong> (其中, 请求返回状态码为407时, chrome浏览器会触发onerror或者reject掉fetch.)</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>cache表示如何处理缓存, 遵守http规范, 拥有如下几种值:</p>
<ul>
<li>default: 表示fetch请求之前将检查下http的缓存.</li>
<li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li>
<li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li>
<li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li>
<li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li>
<li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li>
</ul>
<p>如果fetch请求的header里包含 <code>If-Modified-Since</code>, <code>If-None-Match</code>, <code>If-Unmodified-Since</code>, <code>If-Match</code>, 或者 <code>If-Range</code> 之一, 且cache的值为 <code>default</code> , 那么fetch将自动把 cache的值设置为 <code>&quot;no-store&quot;</code> .</p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><h5 id="为什么是async-await"><a href="#为什么是async-await" class="headerlink" title="为什么是async/await"></a>为什么是async/await</h5><p>回调深渊一直是jser的一块心病, 虽然ES6提供了 Promise, 将嵌套平铺, 但使用起来依然不便. </p>
<p>要说ES6也提供了generator/yield, 它将一个函数执行暂停, 保存上下文, 再次调用时恢复当时的状态.(学习可参考 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="external">Generator 函数的含义与用法 - 阮一峰的网络日志</a>) 无论如何, 总感觉别扭. 如下摘自推库的一张图.</p>
<p><img src="http://louiszhai.github.io/docImages/ajax22.png" alt=""></p>
<p>我们不难看出其中的差距, callback简单粗暴, 层层回调, 回调越深入, 越不容易捋清楚逻辑. Promise 将异步操作规范化.使用then连接, 使用catch捕获错误, 堪称完美, 美中不足的是, then和catch中传递的依然是回调函数, 与心目中的同步代码不是一个套路.</p>
<p>为此, ES7 提供了更标准的解决方案 — async/await. async/await 几乎没有引入新的语法, 表面上看起来, 它就和alert一样易用,  虽然它尚处于ES7的草案中, 不过这并不影响我们提前使用它.</p>
<h5 id="async-await语法"><a href="#async-await语法" class="headerlink" title="async/await语法"></a>async/await语法</h5><p>async 用于声明一个异步函数, 该函数需返回一个 Promise 对象. 而 await 通常后接一个 Promise对象, 需等待该 Promise 对象的 resolve() 方法执行并且返回值后才能继续执行. (如果await后接的是其他对象, 便会立即执行)</p>
<p>因此, async/await 天生可用于处理 fetch请求(毫无违和感). 如下:</p>
<pre><code class="js">var word = &#39;123&#39;,
    url = &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#39;+word+&#39;&amp;json=1&amp;p=3&#39;;
(async ()=&gt;{
  try {
    let res = await fetch(url, {mode: &#39;no-cors&#39;});//等待fetch被resolve()后才能继续执行
    console.log(res);
  } catch(e) {
    console.log(e);
  }
})();
</code></pre>
<p>自然, async/await 也可处理 Promise 对象.</p>
<pre><code class="js">let wait = function(ts){
  return new Promise(function(resolve, reject){
    setTimeout(resolve,ts,&#39;Copy that!&#39;);
  });
};
(async function(){
  try {
    let res = await wait(1000);//① 等待1s后返回结果
    console.log(res);
    res = await wait(1000);//② 重复执行一次
    console.log(res);
  } catch(e) {
    console.log(e);
  }
})();
//&quot;Copy that!&quot;
</code></pre>
<p>可见使用await后, 可以直接得到返回值, 不必写 <code>.then(callback)</code> , 也不必写 <code>.catch(error)</code> 了, 更可以使用 <code>try catch</code> 标准语法捕获错误.</p>
<p>由于await采用的是同步的写法, 看起来它就和alert函数一样, 可以自动阻塞上下文. 因此它可以重复执行多次, 就像上述代码②一样.</p>
<p>可以看到, await/async 同步阻塞式的写法解决了完全使用 Promise 的一大痛点——不同Promise之间共享数据问题. Promise 需要设置上层变量从而实现数据共享, 而 await/async 就不存在这样的问题, 只需要像写alert一样书写就可以了.</p>
<p>值得注意的是, <strong>await 只能用于 async 声明的函数上下文中</strong>. 如下 forEach 中, 是不能直接使用await的.</p>
<pre><code class="js">let array = [0,1,2,3,4,5];
(async ()=&gt;{
  array.forEach(function(item){
    await wait(1000);//这是错误的写法, 因await不在async声明的函数上下文中
    console.log(item);
  });
})();
</code></pre>
<p>如果是试图将async声明的函数作为回调传给forEach，该回调将同时触发多次，回调内部await依然有效，只是多次的await随着回调一起同步执行了，这便不符合我们阻塞循环的初衷。如下：</p>
<pre><code>const fn = async (item)=&gt;{
  await wait(1000); // 循环中的多个await同时执行，因此等待1s后将同时输出数组各个元素
  console.log(item);
};
array.forEach(fn);
</code></pre><p>正确的写法如下：</p>
<pre><code class="js">(async ()=&gt;{
  for(let i=0,len=array.length;i&lt;len;i++){
    await wait(1000);
    console.log(array[i]);
  }
})();
</code></pre>
<h5 id="如何试运行async-await"><a href="#如何试运行async-await" class="headerlink" title="如何试运行async/await"></a>如何试运行async/await</h5><p>鉴于目前只有Edge支持 async/await, 我们可以使用以下方法之一运行我们的代码.</p>
<ol>
<li><p>随着node7.0的发布, node中可以使用如下方式直接运行:</p>
<pre><code class="bash">node --harmony-async-await test.js
</code></pre>
</li>
<li><p>babel在线编译并运行 <a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;code=" target="_blank" rel="external">Babel · The compiler for writing next generation JavaScript</a> .</p>
</li>
<li><p>本地使用babel编译es6或更高版本es.</p>
<p>1) 安装.</p>
<p>由于Babel5默认自带各种转换插件, 不需要手动安装. 然而从Babel6开始, 插件需要手动下载, 因此以下安装babel后需要再顺便安装两个插件.</p>
<pre><code class="bash">npm i babel-cli -g    # babel已更名为babel-cli
npm install babel-preset-es2015 --save-dev
npm install babel-preset-stage-0 --save-dev
</code></pre>
<p>2) 书写.babelrc配置文件.</p>
<pre><code class="json">{
    &quot;presets&quot;: [
        &quot;es2015&quot;,
        &quot;stage-0&quot;
    ],
    &quot;plugins&quot;: []
}
</code></pre>
<p>3) 如果不配置.babelrc. 也可在命令行显式指定插件.</p>
<pre><code class="bash">babel es6.js -o es5.js --presets es2015 stage-0 # 指定使用插件es2015和stage-0编译js
</code></pre>
<p>4) 编译.</p>
<pre><code class="bash">babel es6.js -o es5.js  # 编译源文件es6.js,输出为es5.js,编译规则在上述.babelrc中指定
babel es6.js --out-file es5.js # 或者将-o写全为--out-file也行
bable es6.js # 如果不指定输出文件路径,babel会将编译生成的文本标准输出到控制台
</code></pre>
<p>5) 实时编译</p>
<pre><code class="bash">babel es6.js -w -o es5.js # 实时watch es6.js的变化,一旦改变就重新编译
babel es6.js -watch -o es5.js # -w也可写全为--watch
</code></pre>
<p>6) 编译目录输出到其他目录</p>
<pre><code class="bash">babel src -d build # 编译src目录下所有js,并输出到build目录
babel src --out-dir build # -d也可写全为--out-dir
</code></pre>
<p>7) 编译目录输出到单个文件</p>
<pre><code class="bash">babel src -o es5.js # 编译src目录所有js,合并输出为es5.js
</code></pre>
<p>8) 想要直接运行es6.js, 可使用babel-node.</p>
<pre><code class="bash">npm i babel-node -g # 全局安装babel-node
babel-node es6.js # 直接运行js文件
</code></pre>
<p>9) 如需在代码中使用fetch, 且使用babel-node运行, 需引入 <code>node-fetch</code> 模块.</p>
<pre><code class="bash">npm i node-fetch --save-dev
</code></pre>
<p>然后在es6.js中require <code>node-fetch</code> 模块.</p>
<pre><code class="js">var fetch = require(&#39;node-fetch&#39;);
</code></pre>
</li>
<li><p>本地使用traceur编译es6或更高版本es.请参考 <a href="http://www.codesec.net/view/450316.html" target="_blank" rel="external">在项目开发中优雅地使用ES6：Traceur &amp; Babel</a> .</p>
</li>
</ol>
<h3 id="如何弥补Fetch的不足"><a href="#如何弥补Fetch的不足" class="headerlink" title="如何弥补Fetch的不足"></a>如何弥补Fetch的不足</h3><p>fetch基于Promise, Promise受限, fetch也难幸免. ES6的Promise基于 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范 (对规范感兴趣的同学可选读 <a href="http://www.cnblogs.com/fsjohnhuang/p/4135149.html" target="_blank" rel="external">剖析源码理解Promises/A规范</a> ), 它只提供极简的api, 没有 timeout 机制, 没有 progress 提示, 没有 deferred 处理 (这个可以被async/await替代).</p>
<h4 id="fetch-jsonp"><a href="#fetch-jsonp" class="headerlink" title="fetch-jsonp"></a>fetch-jsonp</h4><p>除此之外, fetch还不支持jsonp请求. 不过办法总比问题多, 万能的开源作者提供了 <a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="external"><code>fetch-jsonp</code></a> 库, 解决了这个问题. </p>
<p><code>fetch-jsonp</code> 使用起来非常简单. 如下是安装:</p>
<pre><code class="bash">npm install fetch-jsonp --save-dev
</code></pre>
<p>如下是使用:</p>
<pre><code class="js">fetchJsonp(url, {
  timeout: 3000,
  jsonpCallback: &#39;callback&#39;
}).then(function(response) {
  console.log(response.json());
}).catch(function(e) {
  console.log(e)
});
</code></pre>
<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>由于Promise的限制, fetch 并不支持原生的abort机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<blockquote>
<p>Promise.race(iterable) 方法返回一个Promise对象, 只要 iterable 中任意一个Promise 被 resolve 或者 reject 后, 外部的Promise 就会以相同的值被 resolve 或者 reject.</p>
</blockquote>
<p>支持性: 从 chrome33, Firefox29, Safari7.1, Opera20, EdgeHTML12(并非Edge版本) 起, Promise就被完整的支持. Promise.race()也随之可用. 下面我们来看下实现.</p>
<pre><code class="js">var _fetch = (function(fetch){
  return function(url,options){
    var abort = null;
    var abort_promise = new Promise((resolve, reject)=&gt;{
      abort = () =&gt; {
        reject(&#39;abort.&#39;);
        console.info(&#39;abort done.&#39;);
      };
    });
    var promise = Promise.race([
      fetch(url,options),
      abort_promise
    ]);
    promise.abort = abort;
    return promise;
  };
})(fetch);
</code></pre>
<p>然后, 使用如下方法测试新的fetch.</p>
<pre><code class="js">var p = _fetch(&#39;https://www.baidu.com&#39;,{mode:&#39;no-cors&#39;});
p.then(function(res) {
    console.log(&#39;response:&#39;, res);
}, function(e) {
    console.log(&#39;error:&#39;, e);
});
p.abort();
//&quot;abort done.&quot;
//&quot;error: abort.&quot;
</code></pre>
<p>以上, fetch请求后, 立即调用abort方法, 该promise被拒绝, 符合预期. 细心的同学可能已经注意到了, “p.abort();” 该语句我是单独写一行的, 没有链式写在then方法之后. 为什么这么干呢? 这是因为then方法调用后, 返回的是新的promise对象. 该对象不具有abort方法, 因此使用时要注意绕开这个坑.</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>同上, 由于Promise的限制, fetch 并不支持原生的timeout机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<p>下面是一个简易的版本.</p>
<pre><code class="js">function timer(t){
  return new Promise(resolve=&gt;setTimeout(resolve, t))
  .then(function(res) {
    console.log(&#39;timeout&#39;);
  });
}
var p = fetch(&#39;https://www.baidu.com&#39;,{mode:&#39;no-cors&#39;});
Promise.race([p, timer(1000)]);
//&quot;timeout&quot;
</code></pre>
<p>实际上, 无论超时时间设置为多长, 控制台都将输出log “timeout”. 这是因为, 即使fetch执行成功, 外部的promise执行完毕, 此时 setTimeout 所在的那个promise也不会reject.</p>
<p>下面我们来看一个类似xhr版本的timeout.</p>
<pre><code class="js">var _fetch = (function(fetch){
  return function(url,options){
    var abort = null,
        timeout = 0;
    var abort_promise = new Promise((resolve, reject)=&gt;{
      abort = () =&gt; {
        reject(&#39;timeout.&#39;);
        console.info(&#39;abort done.&#39;);
      };
    });
    var promise = Promise.race([
      fetch(url,options),
      abort_promise
    ]);
    promise.abort = abort;
    Object.defineProperty(promise, &#39;timeout&#39;,{
      set: function(ts){
        if((ts=+ts)){
          timeout = ts;
          setTimeout(abort,ts);
        }
      },
      get: function(){
        return timeout;
      }
    });
    return promise;
  };
})(fetch);
</code></pre>
<p>然后, 使用如下方法测试新的fetch.</p>
<pre><code class="js">var p = _fetch(&#39;https://www.baidu.com&#39;,{mode:&#39;no-cors&#39;});
p.then(function(res) {
    console.log(&#39;response:&#39;, res);
}, function(e) {
    console.log(&#39;error:&#39;, e);
});
p.timeout = 1;
//&quot;abort done.&quot;
//&quot;error: timeout.&quot;
</code></pre>
<h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>xhr的 onprogress 让我们可以掌控下载进度, fetch显然没有提供原生api 做类似的事情. 不过 Fetch中的<code>Response.body</code> 中实现了<code>getReader()</code>方法用于读取原始字节流, 该字节流可以循环读取, 直到body下载完成. 因此我们完全可以模拟fetch的progress.</p>
<p>以下是 stackoverflow 上的一段代码, 用于模拟fetch的progress事件. 为了方便测试, 请求url已改为本地服务.(原文请戳 <a href="http://stackoverflow.com/questions/35711724/progress-indicators-for-fetch" target="_blank" rel="external">javascript - Progress indicators for fetch? - Stack Overflow</a>)</p>
<pre><code class="js">function consume(reader) {
  var total = 0
  return new Promise((resolve, reject) =&gt; {
    function pump() {
      reader.read().then(({done, value}) =&gt; {
        if (done) {
          resolve();
          return;
        }
        total += value.byteLength;
        console.log(`received ${value.byteLength} bytes (${total} bytes in total)`);
        pump();
      }).catch(reject)
    }
    pump();
  });
}
fetch(&#39;http://localhost:10101/notification/&#39;,{mode:&#39;no-cors&#39;})
  .then(res =&gt; consume(res.body.getReader()))
  .then(() =&gt; console.log(&quot;consumed the entire body without keeping the whole thing in memory!&quot;))
  .catch(e =&gt; console.log(&quot;something went wrong: &quot; + e));
</code></pre>
<p>以下是日志截图:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax15.png" alt=""></p>
<p>刚好github上有个fetch progress的demo, 感兴趣的小伙伴请参看这里: <a href="https://labs.jxck.io/fetch/progress.html" target="_blank" rel="external">Fetch Progress DEMO</a> .</p>
<p>我们不妨来对比下, 使用xhr的onprogress事件回调, 输出如下:</p>
<p><img src="http://louiszhai.github.io/docImages/ajax16.png" alt=""></p>
<p>当适当增加响应body的size, 发现xhr的onprogress事件回调依然只执行两次. 通过多次测试发现其执行频率比较低, 远不及fetch progress.</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>.</p>
<p>本文作者: <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接: <a href="http://louiszhai.github.io/2016/10/19/fetch/">http://louiszhai.github.io/2016/10/19/fetch/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="external">Fetch Standard</a></li>
<li><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="external">传统 Ajax 已死，Fetch 永生</a></li>
<li><a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="external">体验异步的终极解决方案-ES7的Async/Await</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-promise-constructor" target="_blank" rel="external">ES6-Promise</a></li>
<li><a href="http://www.tuicool.com/articles/QZBJ7zJ" target="_blank" rel="external">译-JavaScript Fetch API</a></li>
<li><a href="http://imweb.io/topic/57c6ea35808fd2fb204eef63" target="_blank" rel="external">让fetch也可以timeout</a></li>
</ul>

      
    </div>
    
  </div>
  
  
    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
       支持一杯咖啡吧！
        </span>
      </div>  
  <div id="donate_guide" class="donate_bar center hidden" >
    <!-- 支付宝打赏图案 -->
    <img src="/img/alipay.gif" alt="支付宝打赏"> 
    <!-- 微信打赏图案 -->
    <img src="/img/weixin.gif" alt="微信打赏">  
    </div>
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function(){
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }
  </script>
</div>
<! -- 添加捐赠图标 -->
  

  
    
<nav id="article-nav">
  
    <a href="/2016/11/02/ajax/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Ajax知识体系大梳理
        
      </div>
    </a>
  
  
    <a href="/2016/07/01/Math/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">全面解读Math对象及位运算</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>










  <style>
/*
    Name:     Kimbie (light)
    Author:   Jan T. Sott
    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License
    URL:      https://github.com/idleberg/Kimbie-highlight.js
*/

/* Kimbie Comment */
.hljs-comment,
.hljs-quote {
  color: #a57a4c;
}

/* Kimbie Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-meta {
  color: #dc3958;
}

/* Kimbie Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion,
.hljs-link {
  color: #f79a32;
}

/* Kimbie Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #f06431;
}

/* Kimbie Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #889b4a;
}

/* Kimbie Purple */
.hljs-keyword,
.hljs-selector-tag,
.hljs-function {
  color: #98676a;
}

.hljs {
  display: block;
  overflow-x: auto;
  /*background: #fbebd4;*/
  color: #84613d;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    // hljs.initHighlightingOnLoad();
    [].slice.call(document.querySelectorAll('pre code')).forEach(function(block, i) {
      hljs.highlightBlock(block);
      var lines = block.innerText.split('\n').length - 1;
      var ul = document.createElement('ul');
      ul.className = 'pre-numbering';
      block.className += ' has-numbering';
      block.parentNode.appendChild(ul);
      for(i=1;i<=lines;i++){
        var li = document.createElement('li');
        li.innerText = i;
        ul.appendChild(li);
      }
    });
  </script>
</div>
        <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2023 路易斯

        <span style="position:relative;top:2px" id="cnzz_stat_icon_1256923583"></span>
        <script type="text/javascript">
          var s = document.createElement('script');
          var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
          s.src = cnzz_protocol + "s11.cnzz.com/z_stat.php?id=1256923583&show=pic";
          document.body.appendChild(s);
        </script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/content.js"></script>







</div>
<script src="/js/screenfull.js"></script>
<a href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img
            source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            src="/img/fork_me_on_github.png" alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>
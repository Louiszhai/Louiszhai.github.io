<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>webpack与browser-sync热更新原理深度讲解 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack与browser-sync热更新原理深度讲解">
<meta property="og:url" content="http://louiszhai.github.io/2017/04/19/hmr/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="EventSource 热更新 webpack热更新延迟 websocket 心跳连接 Frame Socket.IO browser-sync webpack-hot-middleware">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hmr11.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hmr12.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace01.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace02.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace04.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace03.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace09.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace05.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace07.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace06.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace08.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/hot-replace10.png">
<meta property="article:published_time" content="2017-04-19T02:10:00.000Z">
<meta property="article:modified_time" content="2019-12-02T03:28:32.883Z">
<meta property="article:author" content="路易斯">
<meta property="article:tag" content="Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://louiszhai.github.io/docImages/hmr11.png">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div id="container">
    <div class="left-col">
        <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://louiszhai.github.io/i.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">路易斯</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 16.67px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/JavaScript-Canvas/" style="font-size: 10px;">JavaScript Canvas</a> <a href="/tags/JavaScript-Chrome-Extension/" style="font-size: 10px;">JavaScript Chrome-Extension</a> <a href="/tags/Tool/" style="font-size: 16.67px;">Tool</a> <a href="/tags/Web/" style="font-size: 16.67px;">Web</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhangxinxu.com/wordpress/category/js/">张鑫旭-鑫空间-鑫生活</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://evanyou.me/">尤雨溪主页</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
        <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">路易斯</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://louiszhai.github.io/i.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">路易斯</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

        <div class="body-wrap"><article id="post-hmr" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/19/hmr/" class="article-date">
  	<time datetime="2017-04-19T02:10:00.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      webpack与browser-sync热更新原理深度讲解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-hot-middleware"><span class="toc-text">webpack-hot-middleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventSource"><span class="toc-text">EventSource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx%E9%85%8D%E7%BD%AE"><span class="toc-text">nginx配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#browser-sync"><span class="toc-text">browser-sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%80%A7"><span class="toc-text">支持性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame"><span class="toc-text">Frame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">服务端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF"><span class="toc-text">发送和监听消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">拥有的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E8%BF%9E%E6%8E%A5"><span class="toc-text">心跳连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket-IO"><span class="toc-text">Socket.IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol>
</div>
      
        <p><strong>本文首发于CSDN网站，下面的版本又经过进一步的修订。</strong></p>
<p>开发环境页面热更新早已是主流，我们不光要吃着火锅唱着歌，享受热更新高效率的快感，更要深入下去探求其原理。</p>
<p>要知道，触类则旁通，常见的需求如赛事网页推送比赛结果、网页实时展示投票或点赞数据、在线评论或弹幕、在线聊天室等，都需要借助热更新功能，才能达到实时的端对端的极致体验。</p>
<p>刚好，最近解决<code>webpack-hot-middleware</code>热更新延迟问题的过程中，我深入接触了EventSource技术。遂本文由此开篇，进一步讲解<code>webpack-hot-middleware</code>，<code>browser-sync</code>背后的技术。</p>
<a id="more"></a>
<h3 id="webpack-hot-middleware"><a href="#webpack-hot-middleware" class="headerlink" title="webpack-hot-middleware"></a><strong>webpack-hot-middleware</strong></h3><p><code>webpack-hot-middleware</code>中间件是webpack的一个plugin，通常结合<code>webpack-dev-middleware</code>一起使用。借助它可以实现浏览器的无刷新更新（热更新），即webpack里的HMR（Hot Module Replacement）。如何配置请参考 <a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="external">webpack-hot-middleware</a>，如何理解其相关插件请参考 <a href="https://segmentfault.com/a/1190000005614604?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">手把手深入理解 webpack dev middleware 原理與相關 plugins</a>。</p>
<p>webpack加入<code>webpack-hot-middleware</code>后，内存中的页面将包含HMR相关js，加载页面后，Network栏可以看到如下请求：</p>
<p><img src="http://louiszhai.github.io/docImages/hmr11.png" alt="__webpack_hmr"></p>
<p>__webpack_hmr是一个<code>type</code>为EventSource的请求, 从<code>Time</code>栏可以看出：默认情况下，服务器每十秒推送一条信息到浏览器。</p>
<p><img src="http://louiszhai.github.io/docImages/hmr12.png" alt="hmr每10秒推送一条信息"></p>
<p>如果此时关闭开发服务器，浏览器由于重连机制，将持续抛出类似<code>GET http://www.test.com/__webpack_hmr 502 (Bad Gateway)</code> 这样的错误。重新启动开发服务器后，重连将会成功，此时便会刷新页面。</p>
<p>以上这些便是我们使用时感受到的最初的印象。当然，停留在使用层面不是我们的目标，接下来我们将跳出该中间件，讲解其所使用到的<code>EventSource</code>技术。</p>
<h3 id="EventSource"><a href="#EventSource" class="headerlink" title="EventSource"></a><strong>EventSource</strong></h3><p>EventSource 不是一个新鲜的技术，它早就随着H5规范提出了，正式一点应该叫<code>Server-sent events</code>，即<code>SSE</code>。</p>
<p>鉴于传统的通过ajax轮训获取服务器信息的技术方案已经过时，我们迫切需要一个高效的节省资源的方式去获取服务器信息，一旦服务器资源有更新，能够及时地通知到客户端，从而实时地反馈到用户界面上。EventSource就是这样的技术，它本质上还是HTTP，通过response流实时推送服务器信息到客户端。</p>
<p>新建一个EventSource对象非常简单。</p>
<pre><code class="js">const es = new EventSource(&#39;/message&#39;);// /message是服务端支持EventSource的接口
</code></pre>
<p>新创建的EventSource对象拥有如下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url(只读)</td>
<td style="text-align:center">es对象请求的服务器url</td>
</tr>
<tr>
<td style="text-align:center">readyState(只读)</td>
<td style="text-align:center">es对象的状态，初始为0，包含CONNECTING (0)，OPEN (1)，CLOSED (2)三种状态</td>
</tr>
<tr>
<td style="text-align:center">withCredentials</td>
<td style="text-align:center">是否允许带凭证等，默认为false，即不支持发送cookie</td>
</tr>
</tbody>
</table>
<p>服务端实现<code>/message</code>接口，需要返回类型为 <code>text/event-stream</code>的响应头。</p>
<pre><code class="js">var http = require(&#39;http&#39;);
http.createServer(function(req，res){
  if(req.url === &#39;/message&#39;){
    res.writeHead(200，{
      &#39;Content-Type&#39;: &#39;text/event-stream&#39;,
      &#39;Cache-Control&#39;: &#39;no-cache&#39;,
      &#39;Connection&#39;: &#39;keep-alive&#39;
    });
    setInterval(function(){
      res.write(&#39;data: &#39; + +new Date() + &#39;\n\n&#39;);
    }, 1000);
  }
}).listen(8888);
</code></pre>
<p>我们注意到，为了避免缓存，Cache-Control 特别设置成了 no-cache，为了能够发送多个response， Connection被设置成了keep-alive.。发送数据时，请务必保证服务器推送的数据以 <code>data:</code>开始，以<code>\n\n</code>结束，否则推送将会失败(原因就不说了，这是约定的)。</p>
<p>以上，服务器每隔1s主动向客户端发送当前时间戳，为了接受这个信息，客户端需要监听服务器。如下：</p>
<pre><code class="js">es.onmessage = function(e){
  console.log(e.data); // 打印服务器推送的信息
}
</code></pre>
<p>如下是消息推送的过程：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace01.gif" alt="response size不断增加"></p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace02.gif" alt="接收消息"></p>
<p>你以为es只能监听message事件吗？并不是，message只是缺省的事件类型。实际上，它可以监听任何指定类型的事件。</p>
<pre><code class="js">es.addEventListener(&quot;####&quot;, function(e) {// 事件类型可以随你定义
  console.log(&#39;####:&#39;, e.data);
}，false);
</code></pre>
<p>服务器发送不同类型的事件时，需要指定event字段。</p>
<pre><code class="js">res.write(&#39;event: ####\n&#39;);
res.write(&#39;data: 这是一个自定义的####类型事件\n&#39;);
res.write(&#39;data: 多个data字段将被解析成一个字段\n\n&#39;);
</code></pre>
<p>如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace04.png" alt="####消息"></p>
<p>可以看到，服务端指定event事件名为”####”后，客户端触发了对应的事件回调，同时服务端设置的多个data字段，客户端使用换行符连接成了一个字符串。</p>
<p>不仅如此，事件流中还可以混合多种事件，请看我们是怎么收到消息的，如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace03.gif" alt="混合消息"></p>
<p>除此之外，es对象还拥有另外3个方法: <code>onopen()</code>、<code>onerror()</code>、<code>close()</code>，请参考如下实现。</p>
<pre><code class="js">es.onopen = function(e){// 链接打开时的回调
  console.log(&#39;当前状态readyState:&#39;, es.readyState);// open时readyState===1
}
es.onerror = function(e){// 出错时的回调(网络问题,或者服务下线等都有可能导致出错)
  console.log(es.readyState);// 出错时readyState===0
  es.close();// 出错时，chrome浏览器会每隔3秒向服务器重发原请求,直到成功. 因此出错时，可主动断开原连接.
}
</code></pre>
<p>使用EventSource技术实时更新网页信息十分高效。实际使用中，我们几乎不用担心兼容性问题，主流浏览器都了支持EventSource，当然，除了掉队的IE系。对于不支持的浏览器，其PolyFill方案请参考<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#eventsource" target="_blank" rel="external">HTML5 Cross Browser Polyfills</a>。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>另外，如果需要支持跨域调用，请设置响应头<code>Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>。</p>
<p>如需支持发送cookie，请设置响应头<code>Access-Control-Allow-Origin&#39;: req.headers.origin</code> 和 <code>Access-Control-Allow-Credentials:true</code>，并且创建es对象时，需要明确指定是否发送凭证。如下：</p>
<pre><code class="js">var es = new EventSource(&#39;/message&#39;, {
  withCredentials: true
}); // 创建时指定配置才是有效的
es.withCredentials = true; // 与ajax不同，这样设置是无效的
</code></pre>
<p>以下是主流浏览器对EventSource的CORS的支持：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">iOS</th>
<th style="text-align:center">Android</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">12+</td>
<td style="text-align:center">26+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">7.0+</td>
<td style="text-align:center">4.4+</td>
</tr>
</tbody>
</table>
<h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a><strong>nginx配置</strong></h4><p>既然说到了EventSource，便有必要谈谈遇到的坑，接下来，就说说我遇到的webpack热更新延迟问题。</p>
<p>如我们所知，webpack借助webpack-hot-middleware插件，实现了网页热更新机制，正常情况下，浏览器打开 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 这样的网页即可开始调试。然而实际开发中，由于远程服务器需要种cookie登录态到特定的域名上等原因，因此本地往往会用nginx做一层反向代理。即把 <a href="http://www.test.com" target="_blank" rel="external">http://www.test.com</a> 的请求转发到 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> 上(配置过程这里不详述，具体请参考<a href="http://louiszhai.github.io/2016/11/02/ajax/ajax调试技巧">Ajax知识体系大梳理-ajax调试技巧</a>)。转发过后，发现热更新便延迟了。</p>
<p>原因是nginx默认开启的buffer机制缓存了服务器推送的片段信息，缓存达到一定的量才会返回响应内容。只要关闭proxy_buffering即可。配置如下所示：</p>
<pre><code class="nginx">server {
    listen       80;
    server_name  www.test.company.com;
    location / {
        proxy_pass http://localhost:8080;
        proxy_buffering off;
    }
}
</code></pre>
<p>至此，EventSource部分便告一段落。学习讲究由浅入深，循序渐进。后面我将重点讲解的<code>browser-sync</code>热更新机制，请耐心细读。</p>
<h3 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a><strong>browser-sync</strong></h3><p>开发中使用<code>browser-sync</code>插件调试，一个网页里的所有交互动作（包括滚动，输入，点击等等），可以实时地同步到其他所有打开该网页的设备，能够节省大量的手工操作时间，从而带来流畅的开发调试体验。目前<code>browser-sync</code>可以结合<code>Gulp</code>或<code>Grunt</code>一起使用，其API请参考：<a href="http://www.browsersync.cn/docs/api/" target="_blank" rel="external">Browsersync API</a>。</p>
<p>通过上面的了解，我们知道<code>EventSouce</code>的使用是比较便捷的，那为什么<code>browser-sync</code>不使用EventSource技术进行代码推送呢？这是因为<code>browser-sync</code>插件共做了两件事：</p>
<ul>
<li>开发更新了一段新的逻辑，服务器实时推送代码改动信息。数据流：服务器 —&gt; 浏览器，使用EventSource技术同样能够实现。</li>
<li>用户操作网页，滚动、输入或点击等，操作信息实时发送给服务器，然后再由服务器将操作同步给其他已打开的网页。数据流：浏览器 —&gt; 服务器 —&gt; 浏览器，该部分功能EventSource技术已无能为力。</li>
</ul>
<p>以上，<code>browser-sync</code>使用WebSocket技术达到实时推送代码改动和用户操作两个目的。至于它是如何计算推送内容，根据不同推送内容采取何种响应策略，不在本次讨论范围之内。下面我们将讲解其核心的WebSocket技术。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h3><p>WebSocket是基于TCP的全双工通讯的协议，它与EventSource有着本质上的不同.(前者基于TCP，后者依然基于HTTP) 该协议于2011年被IETF定为标准RFC6455，后被RFC7936补充. WebSocket api也被W3C定为标准。</p>
<p>WebSocket使用和HTTP相同的TCP端口，默认为80， 统一资源标志符为ws，运行在TLS之上时，默认使用443，统一资源标志符为wss。它通过<code>101 switch protocol</code>进行一次TCP握手，即从HTTP协议切换成WebSocket通信协议。</p>
<p>相对于HTTP协议，WebSocket拥有如下优点：</p>
<ul>
<li>全双工，实时性更强。</li>
<li>相对于http携带完整的头部，WebSocket请求头部明显减少。</li>
<li>保持连接状态，不用再验权了。</li>
<li>二进制支持更强，Websocket定义了二进制帧，处理更轻松。</li>
<li>Websocket协议支持扩展，可以自定义的子协议，如 <code>permessage-deflate</code> 扩展。</li>
</ul>
<h4 id="支持性"><a href="#支持性" class="headerlink" title="支持性"></a><strong>支持性</strong></h4><p>优秀技术的落地，调研兼容性是必不可少的环节。所幸的是，现代浏览器对WebSocket的支持比较友好，如下是PC端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">IE/Edge</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Opera</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10+</td>
<td style="text-align:center">11+</td>
<td style="text-align:center">16+</td>
<td style="text-align:center">7+</td>
<td style="text-align:center">12.1+</td>
</tr>
</tbody>
</table>
<p>如下是mobile端兼容性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">iOS Safari</th>
<th style="text-align:center">Android</th>
<th style="text-align:center">Android Chrome</th>
<th style="text-align:center">Android UC</th>
<th style="text-align:center">QQ Browser</th>
<th style="text-align:center">Opera Mini</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7.1+</td>
<td style="text-align:center">4.4+</td>
<td style="text-align:center">57+</td>
<td style="text-align:center">11.4+</td>
<td style="text-align:center">1.2+</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h4 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a><strong>Frame</strong></h4><p>根据RFC6455文档，WebSocket协议基于Frame而非Stream（EventSource是基于Stream的）。因此其传输的数据都是Frame（帧）。想要了解数据的往返，弄懂协议处理过程，Frame的解读是必不可少。如下便是Frame的结构：</p>
<pre><code>  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued，if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key，if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre><p>第一个字节包含FIN、RSV、Opcode。</p>
<ul>
<li><p>FIN：size为1bit，标示是否最后一帧。<code>%x0</code>表示还有后续帧，<code>%x1</code>表示这是最后一帧。</p>
</li>
<li><p>RSV1、2、3，每个size都是1bit，默认值都是0，如果没有定义非零值的含义，却出现了非零值，则WebSocket链接将失败。</p>
</li>
<li><p>Opcode，size为4bits，表示『payload data』的类型。如果收到未知的opcode，连接将会断开。已定义的opcode值如下：</p>
<pre><code>%x0:    代表连续的帧
%x1:    文本帧
%x2:    二进制帧
%x3~7:    预留的非控制帧
%x8:    关闭握手帧
%x9:    ping帧，后续心跳连接会讲到
%xA:    pong帧，后续心跳连接会讲到
%xB~F:    预留的非控制帧
</code></pre></li>
</ul>
<p>第二个字节包含Mask、Payload len。</p>
<ul>
<li><p>Mask：size为1bit，标示『payload data』是否添加掩码。所有从客户端发送到服务端的帧都会被置为1，如果置1，<code>Masking-key</code>便会赋值。</p>
<pre><code class="js">//若server是一个WebSocket服务端实例
//监听客户端消息
server.on(&#39;message&#39;, function(msg, flags) {
  console.log(&#39;client say: %s&#39;, msg);
  console.log(&#39;mask value:&#39;, flags.masked);// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1
});
//监听客户端pong帧响应
server.on(&#39;pong&#39;, function(msg, flags) {
  console.log(&#39;pong data: %s&#39;, msg);
  console.log(&#39;mask value:&#39;, flags.masked);// true，进一步佐证了客户端发送到服务端的Mask帧都会被置为1
});
</code></pre>
</li>
<li><p>Payload len：size为7bits，即使是当做无符号整型也只能表示0~127的值，所以它不能表示更大的值，因此规定”Payload data”长度小于或等于125的时候才用来描述数据长度。如果<code>Payload len==126</code>，则使用随后的2bytes（16bits）来存储数据长度。如果<code>Payload len==127</code>，则使用随后的8bytes（64bits）来存储数据长度。</p>
</li>
</ul>
<p>以上，扩展的Payload len可能占据第三至第四个或第三至第十个字节。紧随其后的是”Mask-key”。</p>
<ul>
<li>Mask-key：size为0或4bytes（32bits），默认为0，与前面Mask呼应，从客户端发送到服务端的帧都包含4bytes（32bits）的掩码，一旦掩码被设置，所有接收到的”payload data”都必须与该值以一种算法做异或运算来获取真实值。</li>
<li>Payload data：size为”Extension data” 和 “Application data” 的总和，一般”Extension data”数据为空。</li>
<li>Extension data：默认为0，如果扩展被定义，扩展必须指定”Extension data”的长度。</li>
<li>Application data：占据”Extension data”之后剩余帧的空间。</li>
</ul>
<p>关于Frame的更多理论介绍不妨读读 <a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank" rel="external">学习WebSocket协议—从顶层到底层的实现原理（修订版）</a>。</p>
<p>关于Frame的数据帧解析不妨读读 <a href="https://www.web-tinker.com/article/20306.html" target="_blank" rel="external">WebSocket(贰) 解析数据帧</a> 及其后续文章。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><strong>建立连接</strong></h4><p>了解了Frame的数据结构后，我们来实际练习下。浏览器上，新建一个ws对象十分简单。如下：</p>
<pre><code class="js">let ws = new WebSocket(&#39;ws://127.0.0.1:10103/&#39;);// 本地使用10103端口进行测试
</code></pre>
<p>新建的WebSocket对象如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace09.png" alt="Websocket对象"></p>
<p>这中间包含了一次Websocket握手的过程，我们分两步来理解。</p>
<p>第一步，客户端请求。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace05.png" alt="Websocket Request"></p>
<p>这是一个GET请求，主要字段如下：</p>
<pre><code class="http">Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key:61x6lFN92sJHgzXzCHfBJQ==
Sec-WebSocket-Version:13
</code></pre>
<p>Connection字段指定为Upgrade，表示客户端希望连接升级。</p>
<p>Upgrade字段设置为websocket，表示希望升级至Websocket协议。</p>
<p>Sec-WebSocket-Key字段是随机字符串，服务器根据它来构造一个SHA-1的信息摘要。</p>
<p>Sec-WebSocket-Version表示支持的Websocket版本。RFC6455要求使用的版本是13。</p>
<p>甚至我们可以从请求截图里看出，Origin是<code>file://</code>，而Host是<code>127.0.0.1:10103</code>，明显不是同一个域下，但依然可以请求成功，说明Websocket协议是不受同源策略限制的(同源策略限制的是http协议)。</p>
<p>第二步，服务端响应。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace07.png" alt="Websocket Response"></p>
<p>Status Code: 101 Switching Protocols 表示Websocket协议通过101状态码进行握手。</p>
<p>Sec-WebSocket-Accept字段是由Sec-WebSocket-Key字段加上特定字符串”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，计算SHA-1摘要，然后再base64编码之后生成的. 该操作可避免普通http请求，被误认为Websocket协议。</p>
<p>Sec-WebSocket-Extensions字段表示服务端对Websocket协议的扩展。</p>
<p>以上，WebSocket构造器不止可以传入url，还能传入一个可选的协议名称字符串或数组。</p>
<pre><code class="js">ws = new WebSocket(&#39;ws://127.0.0.1:10103/&#39;, [&#39;abc&#39;,&#39;son_protocols&#39;]);
</code></pre>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a><strong>服务端实现</strong></h4><p>等等，我们慢一点，上面好像漏掉了一步，似乎没有提到服务端是怎么实现的。请继续往下看：</p>
<p>先做一些准备。ws是一个nodejs版的WebSocketServer实现。使用 <code>npm install ws</code> 即可安装。</p>
<pre><code class="js">var WebSocketServer = require(&#39;ws&#39;).Server，
    server = new WebSocketServer({port: 10103});
server.on(&#39;connection&#39;, function(s) {
  s.on(&#39;message&#39;, function(msg) { //监听客户端消息
    console.log(&#39;client say: %s&#39;, msg);
  });
  s.send(&#39;server ready!&#39;);// 连接建立好后，向客户端发送一条消息
});
</code></pre>
<p>以上，<code>new WebSocketServer()</code>创建服务器时如需权限验证，请指定<code>verifyClient</code>为验权的函数。</p>
<pre><code class="js">server = new WebSocketServer({
  port: 10103,
  verifyClient: verify
});
function verify(info){
  console.log(Object.keys(info));// [ &#39;origin&#39;, &#39;secure&#39;, &#39;req&#39; ]
  console.log(info.orgin);// &quot;file://&quot;
  return true;// 返回true时表示验权通过，否则客户端将抛出&quot;HTTP Authentication failed&quot;错误
}
</code></pre>
<p>以上，<code>verifyClient</code>指定的函数只有一个形参，若为它显式指定两个形参，那么第一个参数同上info，第二个参数将是一个<code>cb</code>回调函数。该函数用于显式指定拒绝时的HTTP状态码等，它默认拥有3个形参，依次为：</p>
<ul>
<li>result，布尔值类型，表示是否通过权限验证。</li>
<li>code，数值类型，若result值为false时，表示HTTP的错误状态码。</li>
<li>name，字符串类型，若result值为false时，表示HTTP状态码的错误信息。</li>
</ul>
<pre><code class="js">// 若verify定义如下
function verify(info, cb){
  //一旦拥有第二个形参，如果不调用，默认将通过验权
  cb(false, 401, &#39;权限不够&#39;);// 此时表示验权失败，HTTP状态码为401，错误信息为&quot;权限不够&quot;
  return true;// 一旦拥有第二个形参，响应就被cb接管了，返回什么值都不会影响前面的处理结果
}
</code></pre>
<p>除了<code>port</code> 和 <code>verifyClient</code>设置外，其它设置项及更多API，请参考文档 <a href="https://github.com/websockets/ws/blob/master/doc/ws.md" target="_blank" rel="external">ws-doc</a>。</p>
<h4 id="发送和监听消息"><a href="#发送和监听消息" class="headerlink" title="发送和监听消息"></a><strong>发送和监听消息</strong></h4><p>接下来，我们来实现消息收发。如下是客户端发送消息。</p>
<pre><code class="js">ws.onopen = function(e){
  // 可发送字符串，ArrayBuffer 或者 Blob数据
  ws.send(&#39;client ready!);
};
</code></pre>
<p>客户端监听信息。</p>
<pre><code class="js">ws.onmessage = function(e){
  console.log(&#39;server say:&#39;, e.data);
};
</code></pre>
<p>如下是浏览器的运行截图。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace06.png" alt="message"></p>
<p>消息的内容都在Frames栏，第一条彩色背景的信息是客户端发送的，第二条是服务端发送的。两条消息的长度都是13。</p>
<p>如下是Timing栏，不止是WebSocket，包括EventSource，都有这样的黄色高亮警告。</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace08.png" alt="Websocket Request"></p>
<p>该警告说明：请求还没完成。实际上，直到一方连接close掉，请求才会完成。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h4><p>说到close，ws的close方法比es的略复杂。</p>
<p>语法：<em>close(short code，string reason);</em></p>
<p>close默认可传入两个参数。code是数字，表示关闭连接的状态号，默认是1000，即正常关闭。（code取值范围从0到4999，其中有些是保留状态号，正常关闭时只能指定为1000或者3000~4999之间的值，具体请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes" target="_blank" rel="external">CloseEvent - Web APIs</a>）。reason是UTF-8文本，表示关闭的原因（文本长度需小于或等于123字节）。</p>
<p>由于code 和 reason都有限制，因此该方法可能抛出异常，建议catch下.</p>
<pre><code class="js">try{
  ws.close(1001, &#39;CLOSE_GOING_AWAY&#39;);
}catch(e){
  console.log(e);
}
</code></pre>
<p>ws对象还拥有onclose和onerror监听器，分别监听关闭和错误事件。（注：EventSource没有onclose监听）</p>
<h4 id="拥有的属性"><a href="#拥有的属性" class="headerlink" title="拥有的属性"></a><strong>拥有的属性</strong></h4><p>ws的readyState属性拥有4个值，比es的readyState的多一个CLOSING的状态。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">EventSource(值)</th>
<th style="text-align:center">WebSocket(值)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONNECTING</td>
<td style="text-align:center">连接未初始化</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">OPEN</td>
<td style="text-align:center">连接已就绪</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">连接正在关闭</td>
<td style="text-align:center">-</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">CLOSED</td>
<td style="text-align:center">连接已关闭</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>另外，除了两种都有的url属性外，WebSocket对象还拥有更多的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">binaryType</td>
<td style="text-align:center">被传输二进制内容的类型，有blob，arraybuffer两种</td>
</tr>
<tr>
<td style="text-align:center">bufferedAmount</td>
<td style="text-align:center">待传输的数据的长度</td>
</tr>
<tr>
<td style="text-align:center">extensions</td>
<td style="text-align:center">表示服务器选用的扩展</td>
</tr>
<tr>
<td style="text-align:center">protocol</td>
<td style="text-align:center">指的是构造器第二个参数传入的子协议名称</td>
</tr>
</tbody>
</table>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h4><p>以前一直是使用ajax做文件上传，实际上，Websocket上传文件也是一把好刀. 其send方法可以发送String，ArrayBuffer，Blob共三种数据类型，发送二进制文件完全不在话下。</p>
<p>由于各个浏览器对Websocket单次发送的数据有限制，所以我们需要将待上传文件切成片段去发送。如下是实现。</p>
<p>1) html。</p>
<pre><code class="html">&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt;
</code></pre>
<p>2) js。</p>
<pre><code class="js">const ws = new WebSocket(&#39;ws://127.0.0.1:10103/&#39;);// 连接服务器
const fileSelect = document.getElementById(&#39;file&#39;);
const size = 1024 * 128;// 分段发送的文件大小(字节)
let curSize, total, file, fileReader;

fileSelect.onchange = function(){
  file = this.files[0];// 选中的待上传文件
  curSize = 0;// 当前已发送的文件大小
  total = file.size;// 文件大小
  ws.send(file.name);// 先发送待上传文件的名称
  fileReader = new FileReader();// 准备读取文件
  fileReader.onload = loadAndSend;
  readFragment();// 读取文件片段
};

function loadAndSend(){
  if(ws.bufferedAmount &gt; size * 5){// 若发送队列中的数据太多,先等一等
    setTimeout(loadAndSend，4);
    return;
  }
  ws.send(fileReader.result);// 发送本次读取的片段内容
  curSize += size;// 更新已发送文件大小
  curSize &lt; total ? readFragment() : console.log(&#39;upload successed!&#39;);// 下一步操作
}

function readFragment(){
  const blob = file.slice(curSize, curSize + size);// 获取文件指定片段
  fileReader.readAsArrayBuffer(blob);// 读取文件为ArrayBuffer对象
}
</code></pre>
<p>3) server(node)。</p>
<pre><code class="js">var WebSocketServer = require(&#39;ws&#39;).Server,
    server = new WebSocketServer({port: 10103}),// 启动服务器
    fs = require(&#39;fs&#39;);
server.on(&#39;connection&#39;, function(wsServer){
  var fileName, i = 0;// 变量定义不可放在全局,因每个连接都不一样,这里才是私有作用域
  server.on(&#39;message&#39;, function(data, flags){// 监听客户端消息
    if(flags.binary){// 判断是否二进制数据
      var method = i++ ? &#39;appendFileSync&#39; : &#39;writeFileSync&#39;;
      // 当前目录下写入或者追加写入文件(建议加上try语句捕获可能的错误)
      fs[method](&#39;./&#39; + fileName, data，&#39;utf-8&#39;);
    }else{// 非二进制数据则认为是文件名称
      fileName = data;
    }
  });
  wsServer.send(&#39;server ready!&#39;);// 告知客户端服务器已就绪
});
</code></pre>
<p>运行效果如下：</p>
<p><img src="http://louiszhai.github.io/docImages/hot-replace10.png" alt="Websocket upload"></p>
<p>上述测试代码中没有过多涉及服务器的存储过程。通常，服务器也会有缓存区上限，如果客户端单次发送的数据量超过服务端缓存区上限，那么服务端也需要多次读取。</p>
<h4 id="心跳连接"><a href="#心跳连接" class="headerlink" title="心跳连接"></a><strong>心跳连接</strong></h4><p>生产环境下上传一个文件远比本地测试来得复杂。实际上，从客户端到服务端，中间存在着大量的网络链路，如路由器，防火墙等等。一份文件的上传要经过中间的层层路由转发，过滤。这些中间链路可能会认为一段时间没有数据发送，就自发切断两端的连接。这个时候，由于TCP并不定时检测连接是否中断，而通信的双方又相互没有数据发送，客户端和服务端依然会一厢情愿的信任之前的连接，长此以往，将使得大量的服务端资源被WebSocket连接占用。</p>
<p>正常情况下，TCP的四次挥手完全可以通知两端去释放连接。但是上述这种普遍存在的异常场景，将使得连接的释放成为梦幻。</p>
<p>为此，早在websocket协议实现时，设计者们便提供了一种 Ping/Pong Frame的心跳机制。一端发送Ping Frame，另一端以 Pong Frame响应。这种Frame是一种特殊的数据包，它只包含一些元数据，能够在不影响原通信的情况下维持住连接。</p>
<p>根据规范<a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455</a>，Ping Frame包含一个值为9的opcode，它可能携带数据。收到Ping Frame后，Pong Frame必须被作为响应发出。Pong Frame包含一个值为10的opcode，它将包含与Ping Frame中相同的数据。</p>
<p>借助ws包，服务端可以这么来发送Ping Frame。</p>
<pre><code class="js">wsServer.ping();
</code></pre>
<p>同时，需要监听客户端响应的pong Frame.</p>
<pre><code class="js">wsServer.on(&#39;pong&#39;, function(data, flags) {
  console.log(data);// &quot;&quot;
  console.log(flags);// { masked: true，binary: true }
});
</code></pre>
<p>以上，由于Ping Frame 不带数据，因此作为响应的Pong Frame的data值为空串。遗憾的是，目前浏览器只能被动发送Pong Frame作为响应（<a href="http://stackoverflow.com/questions/10585355/sending-websocket-ping-pong-frame-from-browser" target="_blank" rel="external">Sending websocket ping/pong frame from browser</a>），无法通过JS API主动向服务端发送Ping Frame。因此对于web服务，可以采取服务端主动ping的方式，来保持住链接。实际应用中，服务端还需要设置心跳的周期，以保证心跳连接可以一直持续。同时，还应该有重发机制，若连续几次没有收到心跳连接的回复，则认为连接已经断开，此时便可以关闭Websocket连接了。</p>
<h4 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a><strong>Socket.IO</strong></h4><p>WebSocket出世已久，很多优秀的大神基于此开发出了各式各样的库。其中<a href="http://Socket.IO" target="_blank" rel="external">Socket.IO</a>是一个非常不错的开源WebSocke库，旨在抹平浏览器之间的兼容性问题。它基于Node.js，支持以下方式优雅降级：</p>
<ul>
<li>Websocket</li>
<li>Adobe® Flash® Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ul>
<p>如何在项目中使用Socket.IO，请参考<a href="https://github.com/nswbmw/N-chat/wiki/%E7%AC%AC%E4%B8%80%E7%AB%A0-socket.io-%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8" target="_blank" rel="external">第一章 socket.io 简介及使用</a>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>EventSource，本质依然是HTTP，它仅提供服务端到客户端的单向文本数据传输，不需要心跳连接，连接断开会持续触发重连。</p>
<p>WebSocket协议，基于TCP协议，它提供双向数据传输，支持二进制，需要心跳连接，连接断开不会重连。</p>
<p>EventSource更轻量和简单，WebSocket支持性更好（因其支持IE10+）。通常来说，使用EventSource能够完成的功能，使用WebSocket一样能够做到，反之却不行，使用时若遇到连接断开或抛错，请及时调用各自的<code>close</code>方法主动释放资源。</p>
<hr>
<p>本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与<a href="#respond">留言和评论</a>。</p>
<p>本文作者： <a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接： <a href="http://louiszhai.github.io/2017/04/19/hmr/">http://louiszhai.github.io/2017/04/19/hmr/</a></p>
<p>参考文章</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="external">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="https://cnodejs.org/topic/5463840472f405c829029f62" target="_blank" rel="external">用node.js实现HTML5原生的comet(长连接) </a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="external">使用服务器发送事件 - Server-sent events</a></li>
<li><a href="http://www.cnblogs.com/tianma3798/p/5852475.html" target="_blank" rel="external">HTML5 文件域+FileReader 分段读取文件并上传(七)-WebSocket</a></li>
<li><a href="http://www.cnblogs.com/axes/p/4514199.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">nodejs实现Websocket的数据接收发送</a></li>
</ul>

      
    </div>
    
  </div>
  
  
    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
       支持一杯咖啡吧！
        </span>
      </div>  
  <div id="donate_guide" class="donate_bar center hidden" >
    <!-- 支付宝打赏图案 -->
    <img src="/img/alipay.gif" alt="支付宝打赏"> 
    <!-- 微信打赏图案 -->
    <img src="/img/weixin.gif" alt="微信打赏">  
    </div>
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function(){
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }
  </script>
</div>
<! -- 添加捐赠图标 -->
  

  
    
<nav id="article-nav">
  
    <a href="/2017/04/28/array/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          【深度长文】JavaScript数组所有API全解密
        
      </div>
    </a>
  
  
    <a href="/2017/04/07/http-cache/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浏览器缓存机制剖析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>










  <style>
/*
    Name:     Kimbie (light)
    Author:   Jan T. Sott
    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License
    URL:      https://github.com/idleberg/Kimbie-highlight.js
*/

/* Kimbie Comment */
.hljs-comment,
.hljs-quote {
  color: #a57a4c;
}

/* Kimbie Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-meta {
  color: #dc3958;
}

/* Kimbie Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion,
.hljs-link {
  color: #f79a32;
}

/* Kimbie Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #f06431;
}

/* Kimbie Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #889b4a;
}

/* Kimbie Purple */
.hljs-keyword,
.hljs-selector-tag,
.hljs-function {
  color: #98676a;
}

.hljs {
  display: block;
  overflow-x: auto;
  /*background: #fbebd4;*/
  color: #84613d;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    // hljs.initHighlightingOnLoad();
    [].slice.call(document.querySelectorAll('pre code')).forEach(function(block, i) {
      hljs.highlightBlock(block);
      var lines = block.innerText.split('\n').length - 1;
      var ul = document.createElement('ul');
      ul.className = 'pre-numbering';
      block.className += ' has-numbering';
      block.parentNode.appendChild(ul);
      for(i=1;i<=lines;i++){
        var li = document.createElement('li');
        li.innerText = i;
        ul.appendChild(li);
      }
    });
  </script>
</div>
        <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2023 路易斯

        <span style="position:relative;top:2px" id="cnzz_stat_icon_1256923583"></span>
        <script type="text/javascript">
          var s = document.createElement('script');
          var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
          s.src = cnzz_protocol + "s11.cnzz.com/z_stat.php?id=1256923583&show=pic";
          document.body.appendChild(s);
        </script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


<script src="/js/content.js"></script>








</div>

<script src="/js/screenfull.js"></script>

<a target="_blank" rel="noopener" href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img
            source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            src="/img/fork_me_on_github.png" alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>
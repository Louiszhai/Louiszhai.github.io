<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>【Chrome扩展开发】定制HTTP请求响应头域 | louis blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IHeader chrome插件开发 chrome扩展开发 定制请求头响应头 一次性消息 长期连接 pageAction browserAction background.js content.js 扩展国际化 右键菜单 扩展状态管理 chrome.webrequest">
<meta name="keywords" content="JavaScript Chrome-Extension">
<meta property="og:type" content="article">
<meta property="og:title" content="【Chrome扩展开发】定制HTTP请求响应头域">
<meta property="og:url" content="http://louiszhai.github.io/2017/11/14/iheader/index.html">
<meta property="og:site_name" content="louis blog">
<meta property="og:description" content="IHeader chrome插件开发 chrome扩展开发 定制请求头响应头 一次性消息 长期连接 pageAction browserAction background.js content.js 扩展国际化 右键菜单 扩展状态管理 chrome.webrequest">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader01.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader05.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader06.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader07.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader08.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader09.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader03.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader04.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader12.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader13.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader11.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader02.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader16.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader14.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader15.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader23.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader19.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader17.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader18.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader21.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader20.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader26.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader27.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader24.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader25.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader30.gif">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader28.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader29.png">
<meta property="og:image" content="http://louiszhai.github.io/docImages/iheader31.gif">
<meta property="og:updated_time" content="2019-12-02T03:28:32.885Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Chrome扩展开发】定制HTTP请求响应头域">
<meta name="twitter:description" content="IHeader chrome插件开发 chrome扩展开发 定制请求头响应头 一次性消息 长期连接 pageAction browserAction background.js content.js 扩展国际化 右键菜单 扩展状态管理 chrome.webrequest">
<meta name="twitter:image" content="http://louiszhai.github.io/docImages/iheader01.png">
  
    <link rel="alternative" href="/atom.xml" title="louis blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div id="container">
    <div class="left-col">
        <div class="overlay">
	<!--<input type="text" class="st-default-search-input" style="position:absolute;top: 50px;left: 35px;">-->
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">路易斯</a></h1>
		</hgroup>

		
		<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 16.67px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/JavaScript-Canvas/" style="font-size: 10px;">JavaScript Canvas</a> <a href="/tags/JavaScript-Chrome-Extension/" style="font-size: 10px;">JavaScript Chrome-Extension</a> <a href="/tags/Tool/" style="font-size: 16.67px;">Tool</a> <a href="/tags/Web/" style="font-size: 16.67px;">Web</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhangxinxu.com/wordpress/category/js/">张鑫旭-鑫空间-鑫生活</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://evanyou.me/">尤雨溪主页</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
        <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">路易斯</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars2.githubusercontent.com/u/8412301?v=3&amp;s=320" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">路易斯</h1>
			</hgroup>
			
			<p class="header-subtitle">坚持原著, 深度思考, 力求简单通俗叙事</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Louiszhai" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

        <div class="body-wrap"><article id="post-iheader" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/14/iheader/" class="article-date">
  	<time datetime="2017-11-14T02:40:15.000Z" itemprop="datePublished">2017-11-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【Chrome扩展开发】定制HTTP请求响应头域
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript-Chrome-Extension/">JavaScript Chrome-Extension</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          <span class="toc-arrow"></span>
<div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#导读"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx反向代理Google"><span class="toc-text">Nginx反向代理Google</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IHeader缘起"><span class="toc-text">IHeader缘起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-Extension简介"><span class="toc-text">Chrome Extension简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何安装扩展"><span class="toc-text">如何安装扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展打包和更新"><span class="toc-text">扩展打包和更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展的基本组成"><span class="toc-text">扩展的基本组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展的核心功能"><span class="toc-text">扩展的核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展如何运行调试"><span class="toc-text">扩展如何运行调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-Extension-API"><span class="toc-text">Chrome Extension API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebRequest-API"><span class="toc-text">WebRequest API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何绑定header监听"><span class="toc-text">如何绑定header监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展状态管理"><span class="toc-text">扩展状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#监听器的状态管理"><span class="toc-text">监听器的状态管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Action图标状态管理"><span class="toc-text">Page Action图标状态管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标签页的状态管理"><span class="toc-text">标签页的状态管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标签页关闭或更新的妥善处理"><span class="toc-text">标签页关闭或更新的妥善处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息通信"><span class="toc-text">消息通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展内部消息通信"><span class="toc-text">扩展内部消息通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#一次性消息通信API"><span class="toc-text">一次性消息通信API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#长期连接消息通信"><span class="toc-text">长期连接消息通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展程序间消息通信"><span class="toc-text">扩展程序间消息通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web页面与扩展间消息通信"><span class="toc-text">Web页面与扩展间消息通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置快捷键"><span class="toc-text">设置快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加右键菜单"><span class="toc-text">添加右键菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装或更新"><span class="toc-text">安装或更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#国际化"><span class="toc-text">国际化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何引用国际化字符串"><span class="toc-text">如何引用国际化字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#预定义消息"><span class="toc-text">预定义消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其它国际化API"><span class="toc-text">其它国际化API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome扩展开发的心得"><span class="toc-text">Chrome扩展开发的心得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
</div>
      
        <p><strong>本文首发于《程序员》杂志2017年第9、10、11期，下面的版本又经过进一步的修订。</strong></p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a><strong>导读</strong></h3><p>对于开发而言，搜索是日常工作，为了提升搜索的效率，以便更快的查询信息，我试着同时搜索4个网站，分别是百度、Google、维基、Bing。一个可行的做法就是网页中嵌入4个iframe，通过js拼接前面4个搜索引擎的Search URL并依次在iframe中加载。这个构思丝毫没有问题，简单粗暴。然而就是这么简单的功能，也无法实现。由于Google网站在HTML的response header中添加了<code>X-Frame-Options</code>字段以防止网页被Frame（这项设置常被用来防止Click Cheats），因此我无法将Google Search加入到iframe中来。那么，我会放弃Google吗？</p>
<a id="more"></a>
<h3 id="Nginx反向代理Google"><a href="#Nginx反向代理Google" class="headerlink" title="Nginx反向代理Google"></a><strong>Nginx反向代理Google</strong></h3><p>显然不会，既然问题出在<code>X-Frame-Options</code>上，我去掉就行了。对于请求或响应头域定制，nginx是个不错的选择，其第三方的<code>ngx_headers_more</code>模块就特别擅长这种处理。由于nginx无法动态加载第三方模块，我动态编译了nginx以便加入<code>ngx_headers_more</code>模块。至此，第一步完成，以下是nginx的部分配置。</p>
<pre><code>location / {
  more_clear_headers &#39;X-Frame-Options&#39;;
}
</code></pre><p>为了让<code>www.google.com</code>正常访问，我需要使用另外一个域名比如<code>louis.google.com</code>。通过nginx，让<code>louis.google.com</code>转发到<code>www.google.com</code>，转发的同时去掉响应头域中的<code>X-Frame-Options</code>字段。于是nginx配置看起来像这样：</p>
<pre><code>server {
  listen 80;
  server_name louis.google.com;
  location / {
    proxy_pass https://www.google.com/;
    more_clear_headers &#39;X-Frame-Options&#39;;
  }
}
</code></pre><p>以上的配置有什么问题吗？且不说http直接转https的问题，即使能转发，实际上由于Google的安全策略限制，我们也访问不了Google首页！</p>
<p>最终我使用了一个Nginx Google代理模块<a href="[https://github.com/cuber/ngx_http_google_filter_module/](https://github.com/cuber/ngx_http_google_filter_module/blob/master/README.zh-CN.md"><code>ngx_http_google_filter_module</code></a>)，nginx配置如下：</p>
<pre><code>server {
    listen 80;
    server_name louis.google.com;
    resolver 192.168.1.1; # 需要设置为当前路由的网关
    location / {
        google on;
        google_robots_allow on;
        more_clear_headers &#39;X-Frame-Options&#39;;
    }
}
</code></pre><p>以上，通过实现一个Google网站的反向代理，代理的同时去掉了响应头域中的<code>X-Frame-Options</code>字段。至此，nginx方案完结。</p>
<p>nginx方案有一个明显的缺陷是，配置中resolver对应的网关IP<code>192.168.1.1</code>是随着路由器的改变而改变的，家里和公司就是两个不同的网关（更别说去星巴克了办公了），因此经常需要手动去修改网关然后重启nginx。</p>
<h3 id="IHeader缘起"><a href="#IHeader缘起" class="headerlink" title="IHeader缘起"></a><strong>IHeader缘起</strong></h3><p>nginx方案的这个缺陷多少有些麻烦，恰好Chrome Extension可以定制headers，为了解决这个问题，我便尝试开发Chrome Extension。（使用Chrome以来，我下载试用过无数的Chrome Extension。每每看到一款优秀的Extension，都要激动好久，总有一种相见恨晚的感觉。Extension以其强大的定制能力，神奇的运行机制征服了无数的开发者，我也不例外。然而无论多少次的学习和模仿，最终的目的还是为了使用，故开发一款定制请求的Extension势在必行。）由于Chrome浏览器与网页的天然联系，使用Chrome Extension的方式去掉响应头域字段，比其它方案要更加简单高效。</p>
<p>要知道，Chrome Extension提供的API中有<code>chrome.webRequest.onHeadersReceived</code>。它能够添加对响应头的监听并同步修改响应头域，去掉<code>X-Frame-Options</code>似乎是小case。</p>
<p>于是新建项目，取名<a href="http://github.com/Louiszhai/IHeader" target="_blank" rel="external">IHeader</a>。目录结构如下：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader01.png" alt="目录结构"></p>
<p>其中，_locales是国际化配置，目前IHeader支持中文和英文两种语言。</p>
<p>res是资源目录，index.html是extension的首页，options.html是选项页面。</p>
<p>manifest.json是extension的声明配置（总入口），在这里配置extension的名称、版本号、图标、快捷键、资源路径以及权限等。</p>
<p>manifest.json贴出来如下：</p>
<pre><code class="json">{
  &quot;name&quot;: &quot;IHeader&quot;, // 扩展名称
  &quot;version&quot;: &quot;1.1.0&quot;, // 扩展版本号
  &quot;icons&quot;: { // 上传到chrome webstore需要32px、64px、128px边长的方形图标
    &quot;128&quot;: &quot;res/images/lightning_green128.png&quot;,
    &quot;32&quot;: &quot;res/images/lightning_green.png&quot;,
    &quot;64&quot;: &quot;res/images/lightning_green64.png&quot;
  },
  &quot;page_action&quot;: { // 扩展的一种类型，说明这是页面级的扩展
    &quot;default_title&quot;: &quot;IHeader&quot;, // 默认名称
    &quot;default_icon&quot;: &quot;res/images/lightning_default.png&quot;, // 默认图标
    &quot;default_popup&quot;: &quot;res/index.html&quot; // 点击时弹出的页面路径
  },
  &quot;background&quot;: { // 扩展在后台运行的脚本
    &quot;persistent&quot;: true, // 由于后台脚本需要持续运行，需要设置为true，反之扩展不活动时可能被浏览器关闭
    &quot;scripts&quot;: [&quot;res/js/message.js&quot;, &quot;res/js/background.js&quot;] // 指定运行的脚本，实际上Chrome会启用一个匿名的html去引用这些js脚本。等同于&quot;pages&quot;:[&quot;background.html&quot;]这种方式（注意这两种互斥，同时设置时，后一种有效）
  },
  &quot;commands&quot;: { // 指定快捷键
    &quot;toggle_status&quot;: { // 快捷命令的名称
      &quot;suggested_key&quot;: { // 快捷命令的热键
        &quot;default&quot;: &quot;Alt+H&quot;,
        &quot;windows&quot;: &quot;Alt+H&quot;,
        &quot;mac&quot;: &quot;Alt+H&quot;,
        &quot;chromeos&quot;: &quot;Alt+H&quot;,
        &quot;linux&quot;: &quot;Alt+H&quot;
      },
      &quot;description&quot;: &quot;Toggle IHeader&quot; // 描述
    }
  },
  &quot;content_scripts&quot;: [ // 随着每个页面加载的内容脚本，通过它可以访问到页面的DOM
    {
      &quot;all_frames&quot;: false, // frame中不加载
      &quot;matches&quot;: [&quot;\u003Call_urls&gt;&quot;], // 匹配所有URL
      &quot;js&quot;: [&quot;res/js/message.js&quot;, &quot;res/js/content.js&quot;] // 内容脚本的路径
    }
  ],
  &quot;default_locale&quot;: &quot;en&quot;, // 默认语言
  &quot;description&quot;: &quot;__MSG_description__&quot;, // 扩展描述
  &quot;manifest_version&quot;: 2, // Chrome 18及更高版本中，应该指定为2，低于v18版本的Chrome浏览器可以指定为1或不指定
  &quot;minimum_chrome_version&quot;: &quot;26.0&quot;, // 最低支持到v26版本，主要受制于chrome.runtime api
  &quot;options_page&quot;: &quot;res/options.html&quot;, // 选项页面的路径
  &quot;permissions&quot;: [ &quot;tabs&quot; , &quot;webRequest&quot;, &quot;webRequestBlocking&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot;, &quot;contextMenus&quot;, &quot;notifications&quot;] // 扩展需要的权限
}
</code></pre>
<h3 id="Chrome-Extension简介"><a href="#Chrome-Extension简介" class="headerlink" title="Chrome Extension简介"></a><strong>Chrome Extension简介</strong></h3><p>开始开发之前，我们先来刷一波基础知识。</p>
<p>Chrome官方明确规定了插件、扩展和应用的区别：</p>
<ul>
<li>插件（Plugin）是通过调用 Webkit 内核 NPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C/C++、Java 等。插件重点在于接入浏览器底层，拥有更多的权限，可调用系统API，因此插件一般都不能跨系统。比如说最近Adobe宣布放弃的Flash，下载资源的迅雷以及网上付款的网银，它们都提供了Chrome插件，用以在特定场景启用并运行，从而实现丰富的功能。</li>
<li>扩展（Extension）是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，它完全基于Chrome浏览器，借助HTML，CSS，JS等web技术实现功能，是Chrome提供的一种可开发的扩展技术。比如说今年横空出世的微信小程序，它就是微信提供的一种扩展技术。相对于插件而言，扩展程序拥有有限的权限和API，对底层系统不感知，从而具有良好的跨平台特性。注意插件和扩展都只有在Chrome启动后才会运行。</li>
<li>应用（Application）同样是用于扩充Chrome浏览器功能。它与扩展的区别就在于，它拥有独立运行的用户界面，并且Chrome未启动时也能独立调用，就像一个独立的App一样。</li>
</ul>
<p>不注意区分的话，我们讲到Chrome插件，往往指的就是以上三者之一。为了避免引起误解，本篇将严格区分概念，避免使用插件这种含糊的说法。</p>
<h4 id="如何安装扩展"><a href="#如何安装扩展" class="headerlink" title="如何安装扩展"></a><strong>如何安装扩展</strong></h4><p>开发扩展，首先得从安装开始，从Chrome 21起，Chrome浏览器就增加了对扩展安装的限制，默认只允许从 Chrome Web Store （Chrome 网上应用店）安装扩展和应用，这意味着用户一般只能安装Chrome Web Store内的扩展和应用。</p>
<p>如果你拖动一个crx安装文件到Chrome浏览器的任何一个普通网页，将会出现如下提示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader05.png" alt="扩展功能、应用和主题背景可能会损害您的计算机"></p>
<p>点击<code>继续</code>按钮，则会在浏览器左上角弹出如下警告。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader06.png" alt="无法添加来自此网站的应用、扩展程序和用于脚本"></p>
<p>如果你恰好在Github上发现一个不错的Chrome扩展程序，而Chrome Web Store中没有。是不是就没有办法安装呢？当然不是的，Chrome浏览器还有三种其它的方式可以加载扩展程序。</p>
<ul>
<li><p>如果是扩展程序源码目录，点击<code>chrome://extensions/</code>页面的<code>加载已解压的扩展程序</code>按钮就可以直接安装。</p>
</li>
<li><p>如果是crx安装文件，直接拖动至<code>chrome://extensions/</code>页面即可安装。安装过程如下所示：</p>
<p>1） 拖放安装</p>
</li>
</ul>
<p><img src="http://louiszhai.github.io/docImages/iheader07.png" alt="拖放以安装"></p>
<pre><code>2）点击添加扩展程序
</code></pre><p><img src="http://louiszhai.github.io/docImages/iheader08.png" alt="添加扩展"></p>
<pre><code>3）添加好的扩展如下所示。
</code></pre><p><img src="http://louiszhai.github.io/docImages/iheader09.png" alt="拖放安装后"></p>
<ul>
<li>启动Chrome时添加参数<code>--enable-easy-off-store-extension-install</code> ，用以开启简单的扩展安装模式，然后就能像之前一样随意拖动crx文件到浏览器页面进行安装。</li>
</ul>
<p>说到安装，自然有人会问，安装了某款扩展后，怎么查看该扩展的源码呢？Mac系统的用户请记住这个目录<code>~/Library/Application Support/Google/Chrome/Default/Extensions/</code>（windows的扩展目录暂无）。</p>
<h4 id="扩展打包和更新"><a href="#扩展打包和更新" class="headerlink" title="扩展打包和更新"></a>扩展打包和更新</h4><p>另外，中间的<code>打包扩展程序</code>按钮用于将本地开发的扩展程序打包成crx包，首次打包还会生成秘钥文件（如IHeader.pem），如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader03.png" alt="打包扩展程序"></p>
<p><img src="http://louiszhai.github.io/docImages/iheader04.png" alt="已打包好的扩展程序"></p>
<p>打包好的扩展程序，可以发送给其他人安装，或发布到Chrome Web Store（开发者注册费用为5$）。</p>
<p>右边的<code>立即更新扩展程序</code>按钮则用于更新扩展。</p>
<h4 id="扩展的基本组成"><a href="#扩展的基本组成" class="headerlink" title="扩展的基本组成"></a><strong>扩展的基本组成</strong></h4><p>通常一个Chrome扩展包含如下资源或目录：</p>
<ul>
<li>manifest.json入口配置文件（1个，位于根目录）</li>
<li>js文件（至少1个，位于根目录或子级目录）</li>
<li>32px、64px、128px的方形icon各1个（位于根目录或子级目录）</li>
<li>_locales目录， 用于提供国际化支持（可选，位于根目录）</li>
<li>popup.html 弹出页面（可选，位于根目录或子级目录）</li>
<li>background.html 后台运行的页面，主要用于引入多个后台运行的js（可选，位于根目录或子级目录）</li>
<li>options.html 选项页面，用于扩展的设置（可选，位于根目录或子级目录）</li>
</ul>
<p>为了方便管理，个人倾向于将HTML、JS、CSS，ICON等资源分类统一到同一个目录。</p>
<h4 id="扩展的核心功能"><a href="#扩展的核心功能" class="headerlink" title="扩展的核心功能"></a><strong>扩展的核心功能</strong></h4><p>从使用场景上看，Chrome扩展常用的有以下三类：</p>
<p>1）Browser Action，浏览器扩展，可通过manifest.json中的<code>browser_action</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;browser_action&quot;: {
  &quot;default_title&quot;: &quot;Qrcode&quot;,
  &quot;default_icon&quot;: &quot;images/icon.png&quot;,
  &quot;default_popup&quot;: &quot;index.html&quot; // 可选的
},
</code></pre>
<p>以上是URL生成二维码的Browser Action扩展，运行如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader12.gif" alt="Browser Action演示"></p>
<p>该类扩展特点：全局扩展，icon长期占据浏览器右上角工具栏，每个页面均可用。</p>
<p>2）Page Action，页面级扩展，可通过manifest.json中的<code>page_action</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;page_action&quot;: {
  &quot;default_title&quot;: &quot;IHeader&quot;,
  &quot;default_icon&quot;: &quot;res/images/lightning_default.png&quot;,
  &quot;default_popup&quot;: &quot;res/index.html&quot; // 可选的
},
</code></pre>
<p>以上是本篇将要讲解的Page Action的扩展——IHeader，它被指定为所有页面可见，其icon状态切换如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader13.gif" alt="Page Action演示"></p>
<p>该类扩展特点：不同页面可以拥有不同的状态和不同的icon，icon在指定的页面可见，可见时位于浏览器右上角工具栏。</p>
<p>由上可见，Browser Action与Page Action功能上非常相似，配置上各自的内部属性也完全一致，它们不仅可以配置点击时弹出的页面，同时还可以绑定点击事件，如下所示。</p>
<pre><code class="js">chrome.browserAction.onClicked.addListener(function(tab) { // Browser Action
  console.log(tab.id, tab.url);
});
chrome.pageAction.onClicked.addListener(function(tab) { // Page Action
  console.log(tab.id, tab.url);
});
</code></pre>
<p>如果非要说两者的差别，开发中能够感受到的就是：前者不需要维护icon状态，后者需要针对每个启用的页面管理不同的icon状态。</p>
<p>3）Omnibox，全能工具条，可通过manifest.json中的<code>omnibox</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;omnibox&quot;: {
  &quot;keyword&quot;: &quot;mdn-&quot; //URL地址栏输入关键字&quot;mdn-&quot;+空格后，就会触发Omnibox
},
</code></pre>
<p>以上是MDN网站快捷查询的Omnibox扩展，运行如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader11.gif" alt="Omnibox演示"></p>
<p>该类扩展特点：运行在URL地址栏，无弹出界面，用户在输入时，扩展就可以显示建议或者自动完成一些工作。</p>
<p>很明显，你可以对地址栏的各种输入做定制，Chrome的URL地址栏只所以强大，omnibox可谓功不可没。</p>
<p>以上三类决定了扩展如何在浏览器中运行。除此之外，每个扩展程序还可以任意搭载如下页面或脚本。</p>
<ul>
<li><p>Background Page，后台页面，可通过manifest.json中的<code>background</code>属性设置，里面再细分<code>script</code>或<code>page</code>，分别表示脚本和页面，如下所示。</p>
<pre><code class="json">&quot;background&quot;: {
  &quot;persistent&quot;: true, // 默认为false，指定为true时将在后台持续运行
  &quot;scripts&quot;: [&quot;res/js/background.js&quot;] // 指定后台运行的js
  // &quot;page&quot;: [&quot;res/background.html&quot;]  // 指定后台运行的html，html中需引入若干个js
},
</code></pre>
<p>Background Page在扩展中之所以重要，主要归功于<strong>它可以使用所有的Chrome.* API</strong>。借助它<code>popup.js</code> 和 <code>content.js</code> 可以随时进行消息通信，并且调用它们原本无法调用的API。</p>
<p>根据persistent值是否为true，Background Page可分为两类：① <a href="https://developer.chrome.com/extensions/background_pages" target="_blank" rel="external">Persistent Background Pages</a>，② <a href="https://developer.chrome.com/extensions/event_pages" target="_blank" rel="external">Event Pages</a>。前者持续运行，随时可访问；后者只有在事件触发时才能访问。</p>
<p>该页面特点：运行在浏览器后台，无用户界面，后台页面可用于页面间消息通信以及后台监控，一旦浏览器启动，后台页面就会自动运行。</p>
</li>
<li><p>Content Script，内容脚本，可通过manifest.json中的<code>content_scripts</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;content_scripts&quot;: [{
  &quot;all_frames&quot;: true, // 默认为false，指定为true意味着frame中也加载内容脚本
  &quot;matches&quot;: [&quot;\u003Call_urls&gt;&quot;], // 匹配所有URL，意味着任何页面都会加载
  &quot;js&quot;: [&quot;res/js/content.js&quot;], // 指定运行的内容脚本
  &quot;run_at&quot;: &quot;document_end&quot; // 页面加载完成后执行
}],
</code></pre>
<p>除了配置之外，内容脚本还可以通过js的方式动态载入。</p>
<pre><code class="js">// 动态载入js文件
chrome.tabs.executeScript(tabId, {file: &#39;res/js/content.js&#39;});
// 动态载入js语句
chrome.tabs.executeScript(tabId, {code: &#39;alert(&quot;Hello Extension!&quot;)&#39;});
</code></pre>
<p>该脚本特点：每个页面在加载时都会加载内容脚本，加载时机可以指定为<code>document_start</code>、<code>idel</code>或<code>end</code>（分别为页面DOM加载开始时，空闲时及完成后）；<strong>内容脚本是唯一可以访问页面DOM的脚本</strong>，通过它可以操作页面的DOM节点，从而影响视觉呈现；基于安全考虑，内容脚本被设计成与页面其他的JS存在于两个不同的沙盒，因此无法互相访问各自的全局变量。</p>
</li>
</ul>
<ul>
<li><p>Option Html，设置页面，可通过manifest.json中的<code>options_page</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;options_page&quot;: &quot;res/options.html&quot;,
</code></pre>
<p>该页面特点：点击扩展程序icon的右键菜单上【选项】按钮进入到设置页面，该页面一般用于扩展的选项设置。</p>
</li>
<li><p>Override Html，替换新建标签页的空白页面，可通过manifest.json中的<code>chrome_url_overrides</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;chrome_url_overrides&quot;:{
  &quot;newtab&quot;: &quot;blank.html&quot;
},
</code></pre>
<p>该页面特点：常用于替换浏览器默认的空白标签页内容，多见于新开标签页时的壁纸程序，基于它你完全可以打造一个属于自己的空白页。</p>
</li>
<li><p>Devtool Page，控制台页面，可通过manifest.json中的<code>devtools_page</code>属性设置，如下所示。</p>
<pre><code class="json">&quot;devtools_page&quot;: &quot;debug.html&quot;,
</code></pre>
<p>该页面特点：随着控制台打开而启动，可用于将扩展收到的消息输出到当前控制台。</p>
</li>
</ul>
<p>总之，对于Chrome扩展而言，Browser Action、Page Action 或 Omnibox之间是互斥的，其它情况下它并不限制你需要添加哪些页面或脚本，只要你愿意，就可以随意组合。</p>
<h4 id="扩展如何运行调试"><a href="#扩展如何运行调试" class="headerlink" title="扩展如何运行调试"></a><strong>扩展如何运行调试</strong></h4><p>只要你会写js，就可以开发Chrome扩展程序了。涉及到开发，调试是不可避免的，Chrome扩展的调试也非常简单。我们都知道Chrome浏览器的 <code>chrome://extensions/</code>页面可以查看所有的Chrome扩展，不仅如此，该页面下的<code>加载已解压的扩展程序</code>按钮，便可以直接加载本地开发的扩展程序，如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader02.png" alt="加载已解压的扩展程序"></p>
<p>注意：需要勾选开发者模式才会出现<code>加载已解压的扩展程序</code>按钮。</p>
<p>成功加载后的扩展跟正常安装的扩展程序，没有什么不同，接下来，我们就可以使用web技术进行调试了。</p>
<ul>
<li>点击以上的<code>选项</code>或<code>背景页</code>按钮，将分别打开选项页面和背景页。选项页面是一个正常的html页面，按<code>⌃+⌘+J</code> 键打开控制台就可以调试了。背景页没有界面，打开的就是控制台。这两个页面都可以断点debug。</li>
<li>Browser Action 或 Page Action的扩展通常在Chrome浏览器的右上角会出现一个Icon，右键点击该Icon，点击右键菜单的<code>审查弹出内容</code>按钮，将会在打开弹出页面的同时打开它的控制台。这个控制台也可以直接debug。</li>
</ul>
<h3 id="Chrome-Extension-API"><a href="#Chrome-Extension-API" class="headerlink" title="Chrome Extension API"></a><strong>Chrome Extension API</strong></h3><p>Chrome陆续向开发者开放了大量的API。使用这些API，我们可以监听或代理网络请求，存储数据，管理标签页和Cookie，绑定快捷键、设置右键菜单，添加通知和闹钟，获取CPU、电池、内存、显示器的信息等等（还有很多没有列举出来）。具体请阅读<a href="https://developer.chrome.com/extensions/api_index" target="_blank" rel="external">Chrome API官方文档</a>。请注意，使用相应的API，往往需要申请对应的权限，如IHeader申请的权限如下所示。</p>
<pre><code class="json">&quot;permissions&quot;: [ &quot;tabs&quot; , &quot;webRequest&quot;, &quot;webRequestBlocking&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot;, &quot;contextMenus&quot;, &quot;notifications&quot;]
</code></pre>
<p>以上，IHeader依次申请了标签页、请求、请求断点、http网站，https网站，右键菜单，桌面通知的权限。</p>
<h3 id="WebRequest-API"><a href="#WebRequest-API" class="headerlink" title="WebRequest API"></a><strong>WebRequest API</strong></h3><p>Chrome Extension API中，能够修改请求的，只有chrome.webRequest了。webRequest能够为请求的不同阶段添加事件监听器，这些事件监听器，可以收集请求的详细信息，甚至修改或取消请求。</p>
<p>事件监听器只在特定阶段触发，它们的触发顺序如下所示。（图片来自<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest" target="_blank" rel="external">MDN</a>）</p>
<p><img src="http://louiszhai.github.io/docImages/iheader16.png" alt=""></p>
<p>事件监听器的含义如下所示。</p>
<ul>
<li><strong>onBeforeRequest</strong>，请求发送之前触发（请求的第1个事件，请求尚未创建，此时可以取消或者重定向请求）。</li>
<li><strong>onBeforeSendHeaders</strong>，请求头发送之前触发（请求的第2个事件，此时可定制请求头，<strong>部分缓存等有关的请求头</strong>（Authorization、Cache-Control、Connection、Content-<br>Length、Host、If-Modified-Since、If-None-Match、If-Range、Partial-Data、Pragma、Proxy-<br>Authorization、Proxy-Connection和Transfer-Encoding）不出现在请求信息中，可以通过添加同名的key覆盖修改其值，但是不能删除）。</li>
<li><strong>onSendHeaders</strong>，请求头发送之前触发（请求的第3个事件，此时只能查看请求信息，可以确认onBeforeSendHeaders事件中都修改了哪些请求头）。</li>
<li><strong>onHeadersReceived</strong>，响应头收到之后触发（请求的第4个事件，此时可定制响应头，且只能修改或删除非缓存相关字段或添加字段，由于响应头允许多个同名字段同时存在，因此无法覆盖修改缓存相关的字段）。</li>
<li><strong>onResponseStarted</strong>，响应内容开始传输之后触发（请求的第5个事件，此时只能查看响应信息，可以确认onHeadersReceived事件中都修改了哪些响应头）。</li>
<li><strong>onCompleted</strong>，响应接受完成后触发（请求的第6个事件，此时只能查看响应信息）。</li>
<li><strong>onBeforeRedirect</strong>，onHeadersReceived事件之后，请求重定向之前触发（此时只能查看响应头信息）。</li>
<li><strong>onAuthRequired</strong>，onHeadersReceived事件之后，收到401或者407状态码时触发（此时可以取消请求、同步提供凭证或异步提供凭证）。</li>
</ul>
<p>以上，凡是能够修改请求的事件监听器，都能够指定其extraInfoSpec参数数组中包含”blocking”字符串（意味着能阻塞请求并修改），反之则不行。</p>
<blockquote>
<p>另外请注意，Chrome对于请求头和响应头的展示有着明确的规定，即控制台中只展示发送出去或刚接收到的字段。因此编辑后的请求字段，控制台的network栏能够正常展示；而编辑后的响应字段由于不属于刚接收到的字段，所以从控制台上就会看不到编辑的痕迹，如同没修改过一样，实际上编辑仍然有效。</p>
</blockquote>
<p>事件监听器含义虽不同，但语法却一致。接下来我们就以onHeadersReceived为例，进行深入分析。</p>
<h3 id="如何绑定header监听"><a href="#如何绑定header监听" class="headerlink" title="如何绑定header监听"></a><strong>如何绑定header监听</strong></h3><p>还记得我们的目标吗？想要去掉Google网站HTML响应头的<code>X-Frame-Options</code>字段。请看如下代码：</p>
<pre><code class="js">// 监听的回调
var callback = function(details) {
  var headers = details.responseHeaders;
  for (var i = 0; i &lt; headers.length; ++i) {
    // 移除X-Frame-Options字段
    if (headers[i].name === &#39;X-Frame-Options&#39;) {
      headers.splice(i, 1);
      break;
    }
  }
  // 返回修改后的headers列表
  return { responseHeaders: headers };
};
// 监听哪些内容
var filter = {
  urls: [&quot;&lt;all_urls&gt;&quot;]
};
// 额外的信息规范，可选的
var extraInfoSpec = [&quot;blocking&quot;, &quot;responseHeaders&quot;];
/* 监听response headers接收事件*/
chrome.webRequest.onHeadersReceived.addListener(callback, filter, extraInfoSpec);
</code></pre>
<p>chrome.webRequest.onHeadersReceived.addListener表示添加一个接收响应头的监听。以上代码中的关键参数或属性，下面逐一讲解。</p>
<ul>
<li>callback，即事件触发时的回调，该回调默认传入一个参数（details），details就是请求的详情。</li>
<li>filter，Object类型，限制事件回调callback触发的过滤器。filter有四个属性可以指定，分别为①urls（包含指定url的数组）、②types（请求的类型，共8种）、③tabId（标签页id）、④windowId（窗口id）。</li>
<li>extraInfoSpec，数组类型，指的是额外的选项列表。对于headersReceived事件而言，包含”blocking”，意味着要求请求同步，基于此才可以修改响应头；包含”responseHeaders”意味着事件回调的默认参数details中将包含responseHeaders字段，该字段指向响应头列表。</li>
</ul>
<p>既然有了添加监听的方法，自然，还会有移除监听的方法。</p>
<pre><code class="js">chrome.webRequest.onHeadersReceived.removeListener(listener);
</code></pre>
<p>除此之外，为了避免重复监听，还可以判断监听是否已经存在。</p>
<pre><code class="js">var bool = chrome.webRequest.onHeadersReceived.hasListener(listener);
</code></pre>
<p>为了保证更好的理清以上属性、方法或参数的逻辑关系，请看如下脑图：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader14.png" alt="headersReceived事件"></p>
<h3 id="扩展状态管理"><a href="#扩展状态管理" class="headerlink" title="扩展状态管理"></a><strong>扩展状态管理</strong></h3><h4 id="监听器的状态管理"><a href="#监听器的状态管理" class="headerlink" title="监听器的状态管理"></a><strong>监听器的状态管理</strong></h4><p>知道了如何绑定监听器，仅仅是第一步。监听器需要在合适的时机绑定，也需要在合适的时机解绑。为了不影响Chrome的访问速度，我们只在需要的标签页创建新的监听器，因此监听器需要依赖filter来区分不同的tabId，考虑到用户可能只需要监听一部分请求类型，types的区分也是不可避免的。又由于一个Tab里不同的时间段可能会加载不同的页面，一个监听器在不同的页面下正常运行也是必须的（因此监听器的filter中不需要指定urls）。</p>
<p>寥寥数语，可能不足以描述出监听器状态管理的原貌，请看下图进一步帮助理解。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader15.png" alt="页面监听器"></p>
<p>以上，一个请求将依次触发上述①②③④⑤五个事件回调，每个事件回调都对应着一个监听器，这些监听器分为两类（从颜色上也可看出端倪）。</p>
<ul>
<li>②③⑤监听器的主要功能是<strong>记录</strong>，用于监听页面上每一个Request的请求头和响应头，以及请求响应时间。</li>
<li>①④监听器的主要功能是<strong>更新</strong>，用于增加、删除或修改指定Request的请求头和响应头。</li>
</ul>
<p>若Chrome指定的标签页激活了IHeader扩展，②③⑤监听器就会记录当前标签页后续的指定类型的请求信息。若用户在激活了IHeader扩展的标签页更新了Request的请求头或响应头，①或④监听器就会被开启。不用担心监听器开启无限个，我准备了回收机制，单个标签页的所有监听器都会在标签页关闭或IHeader扩展取消激活后释放掉。</p>
<p>首先，为方便管理，先封装下监听器的代码。</p>
<pre><code class="js">/* 独立的监听器 */
var Listener = (function(){
  var webRequest = chrome.webRequest;

  function Listener(type, filter, extraInfoSpec, callback){
    this.type = type; // 事件名称
    this.filter = filter; // 过滤器
    this.extraInfoSpec = extraInfoSpec; // 额外的参数
    this.callback = callback; // 事件回调
    this.init();
  }
  Listener.prototype.init = function(){
    webRequest[this.type].addListener( // 添加一个监听器
      this.callback,
      this.filter,
      this.extraInfoSpec
    );
    return this;
  };
  Listener.prototype.remove = function(){
    webRequest[this.type].removeListener(this.callback); // 移除监听器
    return this;
  };
  Listener.prototype.reload = function(){ // 重启监听器(用于选项页面更新请求类型后重启所有已开启的监听器)
    this.remove().init();
    return this;
  };
  return Listener;
})();
</code></pre>
<p>监听器封装好了，剩下的便是管理，监听器控制器基于标签页的维度统一管理标签页上所有的监听器，代码如下。</p>
<pre><code class="js">/* 监听器控制器 */
var ListenerControler = (function(){
  var allListeners = {}; /* 所有的监听器控制器列表 */
  function ListenerControler(tabId){
    if(allListeners[tabId]){ /* 如有就返回已有的实例 */
      return allListeners[tabId];
    }
    if(!(this instanceof ListenerControler)){ /* 强制以构造器方式调用 */
      return new ListenerControler(tabId);
    }

    /* 初始化变量 */
    var _this = this;
    var filter = getFilter(tabId); // 获取当前监听的filter设置
    /* 捕获requestHeaders */
    var l1 = new Listener(&#39;onSendHeaders&#39;, filter, [&#39;requestHeaders&#39;], function(details){
      _this.saveMesage(&#39;request&#39;, details); // 记录请求的头域信息
    });
    /* 捕获responseHeaders */
    var l2 = new Listener(&#39;onResponseStarted&#39;, filter, [&#39;responseHeaders&#39;], function(details){
      _this.saveMesage(&#39;response&#39;, details); // 记录响应的头域信息
    });
    /* 捕获 Completed Details */
    var l3 = new Listener(&#39;onCompleted&#39;, filter, [&#39;responseHeaders&#39;], function(details){
      _this.saveMesage(&#39;complete&#39;, details); // 记录请求完成时的时间等信息
    });

    allListeners[tabId] = this; // 记录当前的标签页控制器
    this.tabId = tabId;
    this.listeners = {  // 记录已开启的监听器
      &#39;onSendHeaders&#39;: l1,
      &#39;onResponseStarted&#39;: l2,
      &#39;onCompleted&#39;: l3
    };
    this.messages = {}; // 当前标签页的请求信息集合
    console.log(&#39;tabId=&#39; + tabId + &#39; listener on&#39;);
  }
  ListenerControler.has = function(tabId){...} // 判断是否包含指定标签页的控制器
  ListenerControler.get = function(tabId){...} // 返回指定标签页的控制器
  ListenerControler.getAll = function(){...} // 获取所有的标签页控制器
  ListenerControler.remove = function(tabId){...} // 移除指定标签页下的所有监听器
  ListenerControler.prototype.remove = function(){...} // 移除当前控制器中的所有监听器
  ListenerControler.prototype.saveMesage = function(type, message){...} // 记录请求信息
  return ListenerControler;
})();
</code></pre>
<p>通过监听器控制器的统一调度，标签页中的多个监听器才能高效的工作。</p>
<p>实际上，还有很多工作，上述代码还没有体现出来。比方说用户在激活了IHeader扩展的标签页更新了Request的请求头或响应头，①beforeSendHeaders或④headersReceived监听器又是怎么运作的呢？这部分内容，请结合『如何绑定header监听』节点的内容理解。</p>
<h4 id="Page-Action图标状态管理"><a href="#Page-Action图标状态管理" class="headerlink" title="Page Action图标状态管理"></a><strong>Page Action图标状态管理</strong></h4><p>标签页控制器的状态需要由视觉体现出来，因此Page Action图标的管理也是不可避免的。通常，默认的icon可以在manifest.json中指定。</p>
<pre><code class="json">&quot;page_action&quot;: {
  &quot;default_icon&quot;: &quot;res/images/lightning_default.png&quot;, // 默认图标
},
</code></pre>
<p>icon有如下3种状态（后两种状态可以互相切换）。</p>
<ul>
<li>默认状态，展示默认的icon。</li>
<li>初始状态，展示扩展初始化后的icon。</li>
<li>激活状态，展示扩展激活后的icon。</li>
</ul>
<p>Chrome提供了chrome.pageAction的API供Page Action使用。目前chrome.pageAction拥有如下方法。</p>
<ul>
<li>show，在指定的tab下展示Page Action。</li>
<li>hide，在指定的tab下隐藏Page Action。</li>
<li>setTitle，设置Page Action的标题（鼠标移动到该Page Action上时会出现设置好的标题提示）</li>
<li>getTitle，获取Page Action的标题。</li>
<li>setIcon，设置Page Action的图标。</li>
<li>setPopup，设置点击时弹出页面的URL。</li>
<li>getPopup，获取点击时弹出页面的URL。</li>
</ul>
<p>以上，setTitle、setIcon 和 show方法比较常用。其中，show方法有两种作用，①展示icon，②更新icon，因此一般是先设置好icon的标题和路径，然后调用show展示出来（或更新）。需要注意的是，Page Action在show方法被调用之前，是不会响应点击的，所以需要在初始化工作结束之前调用show方法。千言万语不如上代码，如下。</p>
<pre><code class="js">/* 声明3种icon状态 */
var UNINIT = 0, // 扩展未初始化
    INITED = 1, // 扩展已初始化，但未激活
    ACTIVE = 2; // 扩展已激活
/* 处理扩展icon状态 */
var PageActionIcon = (function(){
  var pageAction = chrome.pageAction, icons = {}, tips = {};
  icons[INITED] = &#39;res/images/lightning_green.png&#39;; // 设置不同状态下的icon路径(相对于扩展根目录)
  icons[ACTIVE] = &#39;res/images/lightning_red.png&#39;;

  tips[INITED] = Text(&#39;iconTips&#39;); // 其它地方有处理，Text被指向chrome.i18n.getMessage，用以读取_locales中指定语言的对应字段的文本信息
  tips[ACTIVE] = Text(&#39;iconHideTips&#39;);

  function PageActionIcon(tabId){ // 构造器
    this.tabId  = tabId;
    this.status = UNINIT; // 默认为未初始化状态
    pageAction.show(tabId); // 展示Page Action
  }
  PageActionIcon.prototype.init = function(){...} // 初始化icon
  PageActionIcon.prototype.active = function(){...} // icon切换为激活状态
  PageActionIcon.prototype.hide = function(){...} // 隐藏icon
  PageActionIcon.prototype.setIcon = function(){ // 设置icon
    pageAction.setIcon({ // 设置icon的路径
      tabId : this.tabId,
      path  : icons[this.status]
    });
    pageAction.setTitle({ // 设置icon的标题
      tabId : this.tabId,
      title : tips[this.status]
    });
    return this;
  };
  PageActionIcon.prototype.restore = function(){// 刷新页面后，icon之前的状态会丢失，需要手动恢复
    this.setIcon();
    pageAction.show(this.tabId);
    return this;
  };
  return PageActionIcon;
})();
</code></pre>
<p>icon管理的准备工作ok了，剩下的就是使用了，如下。</p>
<pre><code class="js">new PageActionIcon(this.tabId).init();
</code></pre>
<h4 id="标签页的状态管理"><a href="#标签页的状态管理" class="headerlink" title="标签页的状态管理"></a><strong>标签页的状态管理</strong></h4><p>对于IHeader扩展程序，一个标签页同时包含了监听器状态和icon状态的变化。因此需要再抽象出一个标签页控制器，对两者进行统一管理，从而供外部调用。代码如下。</p>
<pre><code class="js">/* 处理标签页状态 */
var TabControler = (function(){
  var tabs = {}; // 所有的标签页控制器列表
  function TabControler(tabId, url){
    if(tabs[tabId]){ /* 如有就返回已有的实例 */
      return tabs[tabId];
    }
    if(!(this instanceof TabControler)){ /* 强制以构造器方式调用 */
      return new TabControler(tabId);
    }
    /* 初始化属性 */
    tabs[tabId] = this;
    this.tabId = tabId;
    this.url    = url;
    this.init();
  }
  TabControler.get = function(tabId){...} // 获取指定的标签页控制器
  TabControler.remove = function(tabId){
    if(tabs[tabId]){
      delete tabs[tabId]; // 移除指定的标签页控制器
      ListenerControler.remove(tabId); // 移除指定的监听器控制器
    }
  };
  TabControler.prototype.init = function(){...} // 初始化标签页控制器
  TabControler.prototype.switchActive = function(){ // 当前标签页状态切换
    var icon = this.icon;
    if(icon){
      var status = icon.status;
      var tabId = this.tabId;
      switch(status){
        case ACTIVE: // 如果是激活状态，则恢复初始状态，移除监听器控制器
          icon.init(); 
          ListenerControler.remove(tabId);
          Message.send(tabId, &#39;ListeningCancel&#39;); // 通知内容脚本从而在控制台输出取消提示(后续将讲到消息通信)
          break;
        default: // 如果不是激活状态，则激活之，添加监听器控制器
          icon.active();
          ListenerControler(tabId);
          Message.send(tabId, &#39;Listening&#39;); // 并通知内容脚本从而在控制台输出监听提示
      }
    }
    return this;
  };
  TabControler.prototype.restore = function(){...} // 恢复标签页控制器的状态(针对页面刷新场景)
  TabControler.prototype.remove = function(){...} // 移除标签页控制器
  return TabControler;
})();
</code></pre>
<p>标签页控制器的抽象，有助于封装扩展的内部运行细节，方便了后续各种场景中对扩展的管理 。</p>
<h4 id="标签页关闭或更新的妥善处理"><a href="#标签页关闭或更新的妥善处理" class="headerlink" title="标签页关闭或更新的妥善处理"></a><strong>标签页关闭或更新的妥善处理</strong></h4><p>标签页关闭或更新时，为了避免内存泄露和运行稳定，部分数据需要释放或者同步。刚刚封装好的标签页控制器就可以用来做这件事。</p>
<p>首先，Tab关闭时需要释放当前标签页的控制器和监听器对象。</p>
<pre><code class="js">/* 监听tab关闭的事件 */
chrome.tabs.onRemoved.addListener(function(tabId, removeInfo){
  TabControler.remove(tabId); // 释放内存，移除标签页控制器和监听器
});
</code></pre>
<p>其次，每次Tab在执行跳转或刷新动作时，Page Action的icon都会回到初始状态并且不可点击，此时需要恢复icon之前的状态。</p>
<pre><code class="js">/* 监听tab更新的事件、包含跳转或刷新的动作 */
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo){
  if(changeInfo.status === &#39;loading&#39;){ // 页面处于loading时触发
    TabControler(tabId).restore(); // 恢复icon状态
  }
});
</code></pre>
<p>以上，页面跳转或刷新时，changeInfo将依次经历两种状态：<code>loading</code> 和<code>complete</code>（部分页面会包含<code>favIconUrl</code>或<code>title</code>信息），如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader23.png" alt="changeInfo"></p>
<p>随着状态管理的逐渐完善，那么，是时候进行消息通信了（不知道你注意到上述代码中出现的Message对象没有？它就是消息处理的对象）。</p>
<h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a><strong>消息通信</strong></h3><h4 id="扩展内部消息通信"><a href="#扩展内部消息通信" class="headerlink" title="扩展内部消息通信"></a><strong>扩展内部消息通信</strong></h4><p>Chrome扩展内的各页面之间的消息通信，有如下四种方式（以下接口省略chrome前缀）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">消息发送</th>
<th style="text-align:center">消息接收</th>
<th style="text-align:center">支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一次性消息</td>
<td style="text-align:center">extension.sendRequest</td>
<td style="text-align:center">extension.onRequest</td>
<td style="text-align:center">v33起废弃（早期方案）</td>
</tr>
<tr>
<td style="text-align:center">一次性消息</td>
<td style="text-align:center">extension.sendMessage</td>
<td style="text-align:center">extension.onMessage</td>
<td style="text-align:center">v20+（不建议使用）</td>
</tr>
<tr>
<td style="text-align:center">一次性消息</td>
<td style="text-align:center">runtime.sendMessage</td>
<td style="text-align:center">runtime.onMessage</td>
<td style="text-align:center">v26+（现在主流，推荐使用）</td>
</tr>
<tr>
<td style="text-align:center">长期连接</td>
<td style="text-align:center">runtime.connect</td>
<td style="text-align:center">runtime.onConnect</td>
<td style="text-align:center">v26+</td>
</tr>
</tbody>
</table>
<p>目前以上四种方案都可以使用。其中<code>extension.sendRequest</code>发送的消息，只有<code>extension.onRequest</code>才能接收到（已废弃不建议使用，可选读<a href="https://codereview.chromium.org/9965005/#ps3001" target="_blank" rel="external">Issue 9965005</a>）。<code>extension.sendMessage</code> 或 <code>runtime.sendMessage</code> 发送的消息，虽然<code>extension.onMessage</code> 和 <code>runtime.onMessage</code>都可以接收，但是runtime api的优先触发。若多个监听同时存在，只有第一个响应才能触发消息的sendResponse回调，其他响应将被忽略，如下所述。</p>
<blockquote>
<p>If multiple pages are listening for onMessage events, only the first to call sendResponse() for a particular event will succeed in sending the response. All other responses to that event will be ignored.</p>
</blockquote>
<p>我们先看一次性的消息通信，它的基本规律如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader19.png" alt="一次性消息通信图示"></p>
<p>图中出现了一种新的消息通信方式，即<code>chrome.extension.getBackgroundPage</code>，通过它能够获取background.js（后台脚本）的window对象，从而调用window下的任意全局方法。严格来说它不是消息通信，但是它完全能够胜任消息通信的工作，之所以出现在图示中，是因为它才是消息从popup.html到background.js的主流沟通方式。那么你可能会问了，为什么content.js中不具有同样的API呢？</p>
<p>这是因为它们的使用方式不同，各自的权限也不同。popup.html或background.js中chrome.extension对象打印如下：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader17.png" alt="chrome.extension对象"></p>
<p>content.js中chrome.extension对象打印如下：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader18.png" alt="content.js下的chrome.extension对象"></p>
<p>可以看出，前者包含了全量的属性，后者只保留少量的属性。content.js中并没有<code>chrome.extension.getBackgroundPage</code>方法，因此content.js不能直接调用background.js中的全局方法。</p>
<p>回到消息通信的话题，请看消息发送和监听的简单示例，如下所示：</p>
<pre><code class="js">// 消息流：弹窗页面、选项页面 或 background.js --&gt; content.js
// 由于每个tab都可能加载内容脚本，因此需要指定tab
chrome.tabs.query( // 查询tab
  { active: true, currentWindow: true }, // 获取当前窗口激活的标签页，即当前tab
  function(tabs) { // 获取的列表是包含一个tab对象的数组
    chrome.tabs.sendMessage( // 向tab发送消息
      tabs[0].id, // 指定tab的id
      { message: &#39;Hello content.js&#39; }, // 消息内容可以为任意对象
      function(response) { // 收到响应后的回调
        console.log(response);
      }
    );
  }
);

/* 消息流：
 * 1. 弹窗页面或选项页面 --&gt; background.js
 * 2. background.js --&gt; 弹窗页面或选项页面
 * 3. content.js --&gt; 弹窗页面、选项页面 或 background.js
 */
chrome.runtime.sendMessage({ message: &#39;runtime-message&#39; }, function(response) {
  console.log(response);
});

// 可任意选用runtime或extension的onMessage方法监听消息
chrome.runtime.onMessage.addListener( // 添加消息监听
  function(request, sender, sendResponse) { // 三个参数分别为①消息内容，②消息发送者，③发送响应的方法
    console.log(sender.tab ?
                &quot;from a content script:&quot; + sender.tab.url :
                &quot;from the extension&quot;);
    if (request.message === &#39;Hello content.js&#39;){
      sendResponse({ answer: &#39;goodbye&#39; }); // 发送响应内容
    }
    // return true; // 如需异步调用sendResponse方法，需要显式返回true
  }
);
</code></pre>
<h5 id="一次性消息通信API"><a href="#一次性消息通信API" class="headerlink" title="一次性消息通信API"></a><strong>一次性消息通信API</strong></h5><p>上述涉及到的API语法如下：</p>
<ul>
<li><em>chrome.tabs.query(object queryInfo, function callback)</em>，查询符合条件的tab。其中，callback为查询结果的回调，默认传入tabs列表作为参数；queryInfo为标签页的描述信息，包含如下属性。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">支持性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">active</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab是否激活</td>
</tr>
<tr>
<td style="text-align:center">audible</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v45+</td>
<td style="text-align:center">tab是否允许声音播放</td>
</tr>
<tr>
<td style="text-align:center">autoDiscardable</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v54+</td>
<td style="text-align:center">tab是否允许被丢弃</td>
</tr>
<tr>
<td style="text-align:center">currentWindow</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v19+</td>
<td style="text-align:center">tab是否在当前窗口中</td>
</tr>
<tr>
<td style="text-align:center">discarded</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v54+</td>
<td style="text-align:center">tab是否处于被丢弃状态</td>
</tr>
<tr>
<td style="text-align:center">highlighted</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab是否高亮</td>
</tr>
<tr>
<td style="text-align:center">index</td>
<td style="text-align:center">Number</td>
<td style="text-align:center">v18+</td>
<td style="text-align:center">tab在窗口中的序号</td>
</tr>
<tr>
<td style="text-align:center">muted</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v45+</td>
<td style="text-align:center">tab是否静音</td>
</tr>
<tr>
<td style="text-align:center">lastFocusedWindow</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">v19+</td>
<td style="text-align:center">tab是否位于最后选中的窗口中</td>
</tr>
<tr>
<td style="text-align:center">pinned</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab是否固定</td>
</tr>
<tr>
<td style="text-align:center">status</td>
<td style="text-align:center">String</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab的状态，可选值为<code>loading</code>或<code>complete</code></td>
</tr>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">String</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab中页面的标题（需要申请tabs权限）</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">String or Array</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab中页面的链接</td>
</tr>
<tr>
<td style="text-align:center">windowId</td>
<td style="text-align:center">Number</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab所处窗口的id</td>
</tr>
<tr>
<td style="text-align:center">windowType</td>
<td style="text-align:center">String</td>
<td style="text-align:center"></td>
<td style="text-align:center">tab所处窗口的类型，值包含<code>normal</code>、<code>popup</code>、<code>panel</code>、<code>app</code>or<code>devtools</code></td>
</tr>
</tbody>
</table>
<p>注：丢弃的tab指的是tab内容已经从内存中卸载，但是tab未关闭。</p>
<ul>
<li><strong><em>chrome.tabs.sendMessage(integer tabId, any request, object options, function responseCallback)</em></strong>，向指定tab下的content.js发送单次消息。其中tabId为标签页的id，request为消息内容，options参数从v41版开始支持，通过它可以指定frameId的值，以便向指定的frame发送消息，responseCallback即收到响应后的回调。</li>
<li><strong><em>chrome.runtime.sendMessage(string extensionId, any message, object options, function responseCallback)</em></strong>，向扩展内或指定的其他扩展发送消息。其中extensionId为其他指定扩展的id，扩展内通信可以忽略该参数，message为消息内容，options参数从v32版开始支持，通过它可以指定includeTlsChannelId（boolean）的值，以便决定TLS通道ID是否会传递到onMessageExternal事件监听回调中，responseCallback即收到响应后的回调。</li>
<li><strong><em>chrome.runtime.onMessage.addListener(function callback)</em></strong>，添加单次消息通信的监听。其中callback类似function(any message, MessageSender sender, function sendResponse) {…}这种函数，message为消息内容，sender即消息发送者，sendResponse用于向消息发送者回复响应，如果需要异步发送响应，请在callback回调中return true（此时将保持消息通道不关闭直到sendResponse方法被调用）。</li>
</ul>
<p>综上，我们选用chrome.runtime api即可完美的进行消息通信，对于v25，甚至v20以下的版本，请参考以下兼容代码。</p>
<pre><code class="js">var callback = function(message, sender, sendResponse) {
  // Do something
});
var message = { message: &#39;hello&#39; }; // message
if (chrome.extension.sendMessage) { // chrome20+
  var runtimeOrExtension = chrome.runtime &amp;&amp; chrome.runtime.sendMessage ? &#39;runtime&#39; : &#39;extension&#39;;
  chrome[runtimeOrExtension].onMessage.addListener(callback); // bind event
  chrome[runtimeOrExtension].sendMessage(message); // send message
} else { // chrome19-
  chrome.extension.onRequest.addListener(callback); // bind event
  chrome.extension.sendRequest(message); // send message
}
</code></pre>
<h5 id="长期连接消息通信"><a href="#长期连接消息通信" class="headerlink" title="长期连接消息通信"></a><strong>长期连接消息通信</strong></h5><p>想必，一次性的消息通信你已经驾轻就熟了。如果是频繁的通信呢？此时，一次性的消息通信就显得有些复杂。为了满足这种频繁通信的需要，Chrome浏览器专门提供了<code>Chrome.runtime.connect</code> API。基于它，通信的双方就可以建立长期的连接。</p>
<p>长期连接基本规律如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader21.png" alt="一次性消息通信图示"></p>
<p>以上，与上述一次性消息通信一样，长期连接也可以在popup.html、background.js 和 content.js三者中两两之间建立（注意：无论何时主动与content.js建立连接，都需要指定tabId）。如下是popup.html与content.js之间建立长期连接的举例🌰。</p>
<pre><code class="js">// popup.html 发起长期连接
chrome.tabs.query(
  {active: true, currentWindow: true}, // 获取当前窗口的激活tab
  function(tabs) {
    // 建立连接，如果是与background.js建立连接，应该使用chrome.runtime.connect api
    var port = chrome.tabs.connect( // 返回Port对象
      tabs[0].id, // 指定tabId
      {name: &#39;call2content.js&#39;} // 连接名称
    );
    port.postMessage({ greeting: &#39;Hello&#39; }); // 发送消息
    port.onMessage.addListener(function(msg) { // 监听消息
      if (msg.say == &#39;Hello, who\&#39;s there?&#39;) {
        port.postMessage({ say: &#39;Louis&#39; });
      } else if (msg.say == &quot;Oh, Louis, how\&#39;s it going?&quot;) {
        port.postMessage({ say: &#39;It\&#39;s going well, thanks. How about you?&#39; });
      } else if (msg.say == &quot;Not good, can you lend me five bucks?&quot;) {
        port.postMessage({ say: &#39;What did you say? Inaudible? The signal was terrible&#39; });
        port.disconnect(); // 断开长期连接
      }
    });
  }
);

// content.js 监听并响应长期连接
chrome.runtime.onConnect.addListener(function(port) { // 监听长期连接，默认传入Port对象
  console.assert(port.name == &quot;call2content.js&quot;); // 筛选连接名称
  console.group(&#39;Long-lived connection is established, sender:&#39; + JSON.stringify(port.sender));
  port.onMessage.addListener(function(msg) {
    var word;
    if (msg.greeting == &#39;Hello&#39;) {
      word = &#39;Hello, who\&#39;s there?&#39;;
      port.postMessage({ say: word });
    } else if (msg.say == &#39;Louis&#39;) {
      word = &#39;Oh, Louis, how\&#39;s it going?&#39;;
      port.postMessage({ say: word });
    } else if (msg.say == &#39;It\&#39;s going well, thanks. How about you?&#39;) {
      word = &#39;Not good, can you lend me five bucks?&#39;;
      port.postMessage({ say: word });
    } else if (msg.say == &#39;What did you say? Inaudible? The signal was terrible&#39;) {
      word = &#39;Don\&#39;t hang up!&#39;;
      port.postMessage({ say: word });
    }
    console.log(msg);
    console.log(word);
  });
  port.onDisconnect.addListener(function(port) { // 监听长期连接的断开事件
    console.groupEnd();
    console.warn(port.name + &#39;: The phone went dead&#39;);
  });
});
</code></pre>
<p>控制台输出如下：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader20.png" alt="扩展内长期连接消息通信输出"></p>
<p>建立长期连接涉及到的API语法如下：</p>
<ul>
<li><em>chrome.tabs.connect(integer tabId, object connectInfo)</em>，与content.js建立长期连接。tabId为标签页的id，connectInfo为连接的配置信息，可以指定两个属性，分别为name和frameId。name属性指定连接的名称，frameId属性指定tab中唯一的frame去建立连接。</li>
<li><em>chrome.runtime.connect(string extensionId, object connectInfo)</em>，发起长期的连接。其中extensionId为扩展的id，connectInfo为连接的配置信息，目前可以指定两个属性，分别是name和includeTlsChannelId。name属性指定连接的名称，includeTlsChannelId属性从v32版本开始支持，表示TLS通道ID是否会传递到onConnectExternal的监听器中。</li>
<li><em>chrome.runtime.onConnect.addListener(function callback)</em>，监听长期连接的建立。callback为连接建立后的事件回调，该回调默认传入Port对象，通过Port对象可进行页面间的双向通信。Port对象结构如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">String</td>
<td style="text-align:center">连接的名称</td>
</tr>
<tr>
<td style="text-align:center">disconnect</td>
<td style="text-align:center">Function</td>
<td style="text-align:center">立即断开连接（已经断开的连接再次调用没有效果，连接断开后将不会收到新的消息）</td>
</tr>
<tr>
<td style="text-align:center">onDisconnect</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">断开连接时触发（可添加监听器）</td>
</tr>
<tr>
<td style="text-align:center">onMessage</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">收到消息时触发（可添加监听器）</td>
</tr>
<tr>
<td style="text-align:center">postMessage</td>
<td style="text-align:center">Function</td>
<td style="text-align:center">发送消息</td>
</tr>
<tr>
<td style="text-align:center">sender</td>
<td style="text-align:center"><a href="https://developer.chrome.com/extensions/runtime#type-MessageSender" target="_blank" rel="external">MessageSender</a></td>
<td style="text-align:center">连接的发起者（该属性只会出现在连接监听器中，即onConnect 或onConnectExternal中）</td>
</tr>
</tbody>
</table>
<h4 id="扩展程序间消息通信"><a href="#扩展程序间消息通信" class="headerlink" title="扩展程序间消息通信"></a><strong>扩展程序间消息通信</strong></h4><p>相对于扩展内部的消息通信而言，扩展间的消息通信更加简单。对于一次性消息通信，共涉及到如下两个API：</p>
<ul>
<li><strong>chrome.runtime.sendMessage</strong>，之前讲过，需要特别指定第一个参数extensionId，其它不变。</li>
<li><strong>chrome.runtime.onMessageExternal</strong>，监听其它扩展的消息，用法与chrome.runtime.onMessage一致。</li>
</ul>
<p>对于长期连接消息通信，共涉及到如下两个API：</p>
<ul>
<li><strong>chrome.runtime.connect</strong>，之前讲过，需要特别指定第一个参数extensionId，其它不变。</li>
<li><strong>chrome.runtime.onConnectExternal</strong>，监听其它扩展的消息，用法与chrome.runtime.onConnect一致。</li>
</ul>
<p>发送消息可参考如下代码：</p>
<pre><code class="js">var extensionId = &quot;oknhphbdjjokdjbgnlaikjmfpnhnoend&quot;; // 目标扩展id
// 发起一次性消息通信
chrome.runtime.sendMessage(extensionId, { message: &#39;hello&#39; }, function(response) {
  console.log(response);
});
// 发起长期连接消息通信
var port = chrome.runtime.connect(extensionId, {name: &#39;web-page-messages&#39;});
port.postMessage({ greeting: &#39;Hello&#39; });
port.onMessage.addListener(function(msg) {
  // 通信逻辑见『长期连接消息通信』popup.html示例代码
});
</code></pre>
<p>监听消息可参考如下代码：</p>
<pre><code class="js">// 监听一次性消息
chrome.runtime.onMessageExternal.addListener( function(request, sender, sendResponse) {
  console.group(&#39;simple request arrived&#39;);
  console.log(JSON.stringify(request));
  console.log(JSON.stringify(sender));
  sendResponse(&#39;bye&#39;);
});
// 监听长期连接
chrome.runtime.onConnect.addListener(function(port) {
  console.assert(port.name == &quot;web-page-messages&quot;);
  console.group(&#39;Long-lived connection is established, sender:&#39; + JSON.stringify(port.sender));
  port.onMessage.addListener(function(msg) {
    // 通信逻辑见『长期连接消息通信』content.js示例代码
  });
  port.onDisconnect.addListener(function(port) {
    console.groupEnd();
    console.warn(port.name + &#39;: The phone went dead&#39;);
  });
});
</code></pre>
<p>控制台输出如下：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader26.png" alt="扩展间消息通信输出"></p>
<h4 id="Web页面与扩展间消息通信"><a href="#Web页面与扩展间消息通信" class="headerlink" title="Web页面与扩展间消息通信"></a><strong>Web页面与扩展间消息通信</strong></h4><p>除了扩展内部和扩展之间的通信，Web pages 也可以与扩展进行消息通信（单向）。这种通信方式与扩展间的通信非常相似，共需要如下三步便可以通信。</p>
<p>首先，manifest.json指定可接收页面的url规则。</p>
<pre><code class="json">&quot;externally_connectable&quot;: {
  &quot;matches&quot;: [&quot;https://developer.chrome.com/*&quot;]
}
</code></pre>
<p>其次，Web pages 发送信息，比如说在 <a href="https://developer.chrome.com/extensions/messaging" target="_blank" rel="external">https://developer.chrome.com/extensions/messaging</a> 页面控制台执行以上『扩展程序间消息通信』小节——消息发送的语句。</p>
<p>最后，扩展监听消息，代码同以上『扩展程序间消息通信』小节——消息监听部分。</p>
<p>至此，扩展程序的消息通信聊得差不多了。基于以上内容，你完全可以自行封装一个message.js，用于简化消息通信。实际上，<a href="https://chrome.google.com/webstore/detail/iibolhpkjjmoepndefdmdlmbpfhlgjpl" target="_blank" rel="external">阅读模式</a>扩展程序就封装了一个<a href="https://github.com/Louiszhai/IHeader/blob/master/res/js/message.js" target="_blank" rel="external">message.js</a>，IHeader扩展中的消息通信便基于它。</p>
<h3 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a><strong>设置快捷键</strong></h3><p>一般涉及到状态切换的，快捷键能有效提升使用体验。为此我也为IHeader添加了快捷键功能。</p>
<p>为扩展程序设置快捷键，共需要两步。</p>
<ol>
<li><p>manifest.json中添加commands声明（可以指定多个命令）。</p>
<pre><code class="json">&quot;commands&quot;: { // 命令
  &quot;toggle_status&quot;: { // 命令名称
    &quot;suggested_key&quot;: { // 指定默认的和各个平台上绑定的快捷键
      &quot;default&quot;: &quot;Alt+H&quot;, 
      &quot;windows&quot;: &quot;Alt+H&quot;,
      &quot;mac&quot;: &quot;Alt+H&quot;,
      &quot;chromeos&quot;: &quot;Alt+H&quot;,
      &quot;linux&quot;: &quot;Alt+H&quot;
    }, 
    &quot;description&quot;: &quot;Toggle IHeader&quot; // 命令的描述
  }
},
</code></pre>
</li>
<li><p>background.js中添加命令的监听。</p>
<pre><code class="js">/* 监听快捷键 */
chrome.commands.onCommand.addListener(function(command) {
  if (command == &quot;toggle_status&quot;) { // 匹配命令名称
    // 查询当前激活tab
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { 
      var tab = tabs[0];
      tab &amp;&amp; TabControler(tab.id, tab.url).switchActive(); // 切换tab控制器的状态
    });
  }
});
</code></pre>
</li>
</ol>
<p>以上，按下<code>Alt+H</code>键，便可以切换IHeader扩展程序的监听状态了。</p>
<p>设置快捷键时，请注意Mac与Windows、linux等系统的差别，Mac既有<code>Ctrl</code>键又有<code>Command</code>键。另外，若设置的快捷键与Chrome的默认快捷键冲突，那么设置将静默失败，因此请记得绕过以下Chrome快捷键（KeyCue是查看快捷键的应用，请忽略之）。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader27.png" alt="Chrome快捷键"></p>
<h3 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a><strong>添加右键菜单</strong></h3><p>除了快捷键外，还可以为扩展程序添加右键菜单，如IHeader的右键菜单。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader24.gif" alt="IHeader右键菜单演示"></p>
<p>为扩展程序添加右键菜单，共需要三步。</p>
<ol>
<li><p>申请菜单权限，需在manifest.json的permissions属性中添加”contextMenus”权限。</p>
<pre><code class="json">&quot;permissions&quot;: [&quot;contextMenus&quot;]
</code></pre>
</li>
<li><p>菜单需在background.js中手动创建。</p>
<pre><code class="js">chrome.contextMenus.removeAll();     // 创建之前建议清空菜单
chrome.contextMenus.create({         // 创建右键菜单
  title: &#39;切换Header监听模式&#39;,         // 指定菜单名称
  id: &#39;contextMenu-0&#39;,                 // 指定菜单id
  contexts: [&#39;all&#39;]                 // 所有地方可见
});
</code></pre>
<p>由于<em>chrome.contextMenus.create(object createProperties, function callback)</em>方法默认返回新菜单的id，因此它通过回调（第二个参数callback）来告知是否创建成功，而第一个参数createProperties则为菜单项指定配置信息。</p>
</li>
<li><p>绑定右键菜单的功能。</p>
<pre><code class="js">chrome.contextMenus.onClicked.addListener(function (menu, tab){
  TabControler(tab.id, tab.url).switchActive();
});
</code></pre>
</li>
</ol>
<h3 id="安装或更新"><a href="#安装或更新" class="headerlink" title="安装或更新"></a><strong>安装或更新</strong></h3><p>Chrome为扩展程序提供了丰富的API，比如说，你可以监听扩展安装或更新事件，进行一些初始化处理或给予友好的提示，如下。</p>
<pre><code class="js">/* 安装提示 */
chrome.runtime.onInstalled.addListener(function(data){
  if(data.reason == &#39;install&#39; || data.reason == &#39;update&#39;){
    chrome.tabs.query({}, function(tabs){
      tabs.forEach(function(tab){
        TabControler(tab.id).restore(); // 恢复所有tab的状态
      });
    });
    // 初始化时重启全局监听器 ...
    // 动态载入Notification js文件
    setTimeout(function(){
      var partMessage = data.reason == &#39;install&#39; ? &#39;安装成功&#39; : &#39;更新成功&#39;;
      chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
        var tab = tabs[0];
        if (!/chrome:\/\//.test(tab.url)){ // 只能在url不是&quot;Chrome:// URL&quot;开头的页面注入内容脚本
          chrome.tabs.executeScript(tab.id, {file: &#39;res/js/notification.js&#39;}, function(){
            chrome.tabs.executeScript(tab.id, {code: &#39;notification(&quot;IHeader&#39;+ partMessage +&#39;&quot;)&#39;}, function(log){
              log[0] &amp;&amp; console.log(&#39;[Notification]: 成功弹出通知&#39;);
            });
          });
        } else {
          console.log(&#39;[Notification]: Cannot access a chrome:// URL&#39;);
        }
      });
    },1000); // 延迟1s的目的是为了调试时能够及时切换到其他的tab下，从而弹出Notification。
    console.log(&#39;[扩展]:&#39;, data.reason);
  }
});
</code></pre>
<p>以上，<em>chrome.tabs.executeScript(integer tabId, object details)</em>接口，用于动态注入内容脚本，且只能在url不是”Chrome:// URL”开头的页面注入。其中tabId参数用于指定目标标签页的id，details参数用于指定内容脚本的路径或语句，它的file属性指定脚本路径，code属性指定动态语句。若分别往同一个标签页注入多个脚本或语句，这些注入的脚本或语句处于同一个沙盒，即全局变量可以共享。</p>
<p>notification.js如下所示。</p>
<pre><code class="js">function notification(message) {
  if (!(&#39;Notification&#39; in window)) { // 判断浏览器是否支持Notification功能
    console.log(&#39;This browser does not support desktop notification&#39;);
  } else if (Notification.permission === &quot;granted&quot;) { // 判断是否授予通知的权限
    new Notification(message); // 创建通知
    return true;
  } else if (Notification.permission !== &#39;denied&#39;) { // 首次向用户申请权限
    Notification.requestPermission(function (permission) { // 申请权限
      if (permission === &quot;granted&quot;) { // 用户授予权限后, 弹出通知
        new Notification(message); // 创建通知
        return true;
      }
    });
  }
}
</code></pre>
<p>最终弹出通知如下。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader25.png" alt="Notification"></p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a><strong>国际化</strong></h3><p>为了让全球都能使用你开发的扩展，国际化是必须的。从软件工程的角度讲，国际化就是将产品用户界面中可见的字符串全部存放在资源文件中，然后根据用户所处不同的语言环境，展示相应语言的视觉信息。Chrome从v17版本开始就提供了国际化标准API——chrome.i18n。i18n即internationalization（国际化），由于i和n中间共计18个字母，故简称为i18n。</p>
<p>Chrome扩展预留了_locales目录，用于存放多种语言版本的资源文件——message.json。目录结构为 “_locales/locales_code/message.json”，如下所示：</p>
<pre><code>_locales
|-- en
    |-- message.json
|-- zh_CN
    |-- message.json
</code></pre><p>locales_code不仅包含以上举例的en（英文）、zh_CN（简体中文）等，还包含全球多种其它语言，具体请参考<a href="https://developer.chrome.com/webstore/i18n?csw=1#localeTable" target="_blank" rel="external">Choosing locales to support</a>，对于不支持的locale，Chrome会自动忽略。</p>
<p>message.json资源文件如下所示，其中key为关键字，其message属性指定了它对应的值，description属性用于描述该key。</p>
<pre><code class="json">{
  &quot;key&quot;: {
    &quot;message&quot;: &quot;the value for the key&quot;,
    &quot;description&quot;: &quot;the description for the key&quot;
  },
  ...
}
</code></pre>
<p>根据i18n的官网文档</p>
<blockquote>
<p><strong>Important:</strong> If an extension has a <code>_locales</code> directory, the manifest <strong>must</strong> define “default_locale”.</p>
</blockquote>
<p>一旦扩展中有了_locales目录，那么就必须要在manifest.json中指定”default_locale”，如下所示。</p>
<pre><code class="json">&quot;default_locale&quot;: &quot;en&quot;,
</code></pre>
<h4 id="如何引用国际化字符串"><a href="#如何引用国际化字符串" class="headerlink" title="如何引用国际化字符串"></a><strong>如何引用国际化字符串</strong></h4><ul>
<li><p>如需在manifest.json或CSS文件中引用一个名称为”key”的字符串，如下所示：</p>
<pre><code>__MSG_key__
</code></pre></li>
<li><p>如需在扩展程序的JS中引用key对应的字符串，则需要借助<em>chrome.i18n.getMessage(string messageName, any substitutions)</em>这个API。其中messageName指的是信息的关键字（key），substitutions数组用于存放字符串待替换字符对应的值（该参数可选，且最多不超过9个替换值）。使用如下所示：</p>
<pre><code class="js">chrome.i18n.getMessage(&quot;key&quot;);
</code></pre>
<p>如果获取不到key对应的值，chrome.i18n.getMessage将返回空字符串<code>&quot;&quot;</code>；若messageName不是字符串或者substitutions数组长度超过9，那么该方法将返回<code>undefined</code>。</p>
<p>那么，如何为message.json添加含有占位符的字符串呢？如下就以IHeader中message.json的代码做测试：</p>
<pre><code class="json">&quot;iconTips&quot;: {
  &quot;message&quot;: &quot;进入Header监听模式 $a$ $b$&quot;,
  &quot;placeholders&quot;: {
    &quot;a&quot;: {
      &quot;content&quot;: &quot;$1&quot;
    },
    &quot;b&quot;: {
      &quot;content&quot;: &quot;$2&quot;
    }
  }
},
</code></pre>
<p>如上，占位符格式为<code>$key$</code>，<code>$key$</code>为字符串待注入标示, key是注入点名称，它需要在placeholders配置中指定第几个substitutions的值注入到这里。如上所述，注入点<code>a</code>的内容指定为<code>$1</code>，即第一个替换的值注入到<code>a</code>所在的位置，注入点<code>b</code>的内容指定为<code>$2</code>，即第二个替换的值注入到<code>b</code>所在的位置，以此类推。</p>
<p>实际上，我们有如下两种方式去注入。</p>
<pre><code class="js">// 替换注入点a为&quot;apple&quot;，如果只是替换一个占位点的话，传入数组或字符串都行
chrome.i18n.getMessage(&#39;iconTips&#39;, &#39;apple&#39;); 
chrome.i18n.getMessage(&#39;iconTips&#39;, [&#39;apple&#39;]);

// 替换注入点a为&quot;apple&quot;，替换b为&quot;oranges&quot;，对于两个或以上的点位的替换，substitutions类型只能为数组
chrome.i18n.getMessage(&#39;iconTips&#39;, [&#39;apple&#39;, &#39;oranges&#39;]);
</code></pre>
</li>
</ul>
<p>实际效果如图：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader30.gif" alt="通过占位符注入内容"></p>
<p>以上引用过程，如下所示（图片来自MDN）：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader28.png" alt="国际化字符串引用图示"></p>
<h4 id="预定义消息"><a href="#预定义消息" class="headerlink" title="预定义消息"></a><strong>预定义消息</strong></h4><p>以上，提供了这些API还不够，国际化系统还提供了一些预定义的消息，它们如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Message Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@@extension_id</td>
<td>扩展ID，可用于拼接链接，即使没有国际化的扩展也可用，注意不能用于manifest.json文件。</td>
</tr>
<tr>
<td style="text-align:center">@@ui_locale</td>
<td>当前语言，可用于拼接本地化的链接。</td>
</tr>
<tr>
<td style="text-align:center">@@bidi_dir</td>
<td>当前语言的文字方向，包含<code>ltr</code>、<code>rtl</code>，分别为从左到右、从右到左。</td>
</tr>
<tr>
<td style="text-align:center">@@bidi_reversed_dir</td>
<td>若@@bidi_dir值为<code>ltr</code>，则它的值为<code>rtl</code>，否则为<code>ltr</code></td>
</tr>
<tr>
<td style="text-align:center">@@bidi_start_edge</td>
<td>若@@bidi_dir值为<code>rtl</code>，则它的值为<code>left</code>，否则为<code>right</code></td>
</tr>
<tr>
<td style="text-align:center">@@bidi_end_edge</td>
<td>若@@bidi_dir值为<code>ltr</code>，则它的值为<code>right</code>，否则为<code>left</code></td>
</tr>
</tbody>
</table>
<p>预定义的消息可在Chrome扩展的JavaScript和CSS中使用，如下。</p>
<pre><code class="js">var extensionId = chrome.i18n.getMessage(&#39;@@extension_id&#39;);
location.href = &#39;chrome-extension://&#39; + extensionId + &#39;/res/options.html&#39;;
</code></pre>
<pre><code class="css">body {
  direction: __MSG_@@bidi_dir__;
  background-image:url(&#39;chrome-extension://__MSG_@@extension_id__/background.png&#39;);
}
div {
  padding-__MSG_@@bidi_start_edge__: 5px;
  padding-__MSG_@@bidi_end_edge__: 10px;
}
</code></pre>
<h4 id="其它国际化API"><a href="#其它国际化API" class="headerlink" title="其它国际化API"></a>其它国际化API</h4><p>除了chrome.i18n.getMessage外，还有另外三个API。</p>
<ul>
<li><p>getAcceptLanguages，获取浏览器可接受的语言列表。</p>
<pre><code class="js">chrome.i18n.getAcceptLanguages(function(languageArray){
    console.log(languageArray);
});
// 由于IHeader只支持中文和英文，故输出 [&quot;zh-CN&quot;, &quot;zh&quot;, &quot;en&quot;, &quot;zh-TW&quot;]
</code></pre>
</li>
<li><p>getUILanguage，获取浏览器用户界面的语言（从Chrome v35起支持）。</p>
<pre><code class="js">chrome.i18n.getUILanguage(); // &quot;zh-CN&quot;
</code></pre>
</li>
<li><p>detectLanguage，使用CLD检测文本对应的语言。</p>
<pre><code class="js">chrome.i18n.detectLanguage(&#39;你好nihaoこんにちは how are you&#39;, function(result){
  console.log(result);
});
</code></pre>
<p>输出如下图：</p>
<p><img src="http://louiszhai.github.io/docImages/iheader29.png" alt="chrome.i18n.detectLanguage"></p>
</li>
</ul>
<h3 id="Chrome扩展开发的心得"><a href="#Chrome扩展开发的心得" class="headerlink" title="Chrome扩展开发的心得"></a><strong>Chrome扩展开发的心得</strong></h3><p>到目前为止，IHeader是我业余开发时间最长的一款Chrome扩展。从去年的5月8号始，到6月14号，第一版才完工，然后又经过7月、8月近两个月的陆续修改，最终v1.1.0版才成型，这才达到了我最初的开发初衷。</p>
<p>现在网络上流传的各种扩展开发教程非常之多，甚至API翻译的网站也很多，就我所知道的至少有这些：</p>
<ul>
<li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">360--扩展开发文档</a></li>
<li><a href="https://chajian.baidu.com/developer/extensions/api_index.html" target="_blank" rel="external">JavaScript API -百度浏览器应用开发文档</a></li>
<li><a href="http://www.ituring.com.cn/book/1421" target="_blank" rel="external">Chrome扩展及应用开发（首发版）</a></li>
<li><a href="http://www.cnblogs.com/champagne/tag/Google%20Chrome%E6%89%A9%E5%B1%95/" target="_blank" rel="external">Chrome扩展开发极客</a></li>
</ul>
<p>通过查看这些资源，基本上就能快速上手Chrome扩展开发。</p>
<p>当然，教程再完善也不及官方文档，开发过程中，最难过的就是Chrome开发者网站连接不稳定，经常无法访问（即使自带梯子），因此查看官方网站的资料有些困难，这点比较影响开发进度，所以本文有意多介绍了一些Chrome API的用法。另外，开发好的扩展发布过程中也需要注意两点：</p>
<ol>
<li>注册Chrome开发者需要5$，亲测浦发的visa信用卡可以支付，没有网上讲的那么复杂。</li>
<li>发布的扩展，为方便用户查看，需要完善的文档。由于Chrome webstore的扩展面向全球用户，所以文档至少要支持两种语言：中文和英文。</li>
</ol>
<p>总之，Chrome扩展，万变不离其宗，无论扩展多么神奇和强大，最终都是通过HTML、CSS、JS来实现功能，脱离不了Web的小天地。因此理论上，只要你会写JS，就完全可以开发Chrome扩展。甚至，连第一个Demo，Chrome都帮你写好了，下载并安装<a href="https://developer.chrome.com/extensions/samples" target="_blank" rel="external">Sample Extensions - Google Chrome</a>网站的随意一个扩展源码，修修改改你就能运行属于自己的扩展了。</p>
<p>当然，一个好的扩展应该是对工作或生活有帮助的。只要你抓住痛点，用心实现功能，利用业余时间开发出一个强大的扩展自然不是问题。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>至此，Chrome扩展有关的介绍差不多了，让我们来看看IHeader的效果。借助IHeader扩展程序，我去掉了 www.google.com 网站response的<code>X-Frame-Options</code>字段，终于解决了文章开头的难题，如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/iheader31.gif" alt="定制response header"></p>
<p>安装好IHeader后，可以戳此链接<a href="http://louiszhai.github.io/res/search/index.html?q=123">http://louiszhai.github.io/res/search/index.html?q=123</a> ，试用IHeader。</p>
<p>不仅如此，IHeader还可以新增、删除或编辑任意指定url的请求响应头，并且即使浏览器重启后，全局监听器依然有效。它适合用于HTTP缓存研究，HTTP接口字段调试，甚至还可以为接口调试时的跨域问题提供临时的解决方案（笔者基于此完成了很多跨域接口的调试工作）。因此，只要您基于HTTP请求响应头去做事情，IHeader都可以帮您简化工作。至于如何使用，这里有一个<a href="https://github.com/Louiszhai/IHeader/blob/master/README_zh_CN.md#iheader" target="_blank" rel="external">IHeader-Guide</a>（由于网络原因，Chrome webstore上更新可能不及时，推荐安装Github上的IHeader源码）。</p>
<p>对Chrome扩展感兴趣的同学，欢迎来<a href="https://github.com/Louiszhai/IHeader/issues" target="_blank" rel="external">Github</a>学习交流扩展开发的经验。</p>
<p>本文以IHeader扩展程序为引，逐步讲解Chrome扩展程序的开发，涉及内容较多，难免有所疏漏，欢迎批评斧正，谢谢。</p>
<hr>
<p>版权声明：转载需注明作者和出处。</p>
<p>本文作者：<a href="https://github.com/Louiszhai" target="_blank" rel="external">louis</a></p>
<p>本文链接：<a href="http://louiszhai.github.io/2017/11/14/iheader/">http://louiszhai.github.io/2017/11/14/iheader/</a></p>
<p>相关文章</p>
<ul>
<li><a href="https://developer.chrome.com/extensions/" target="_blank" rel="external">JavaScript APIs - Google Chrome</a></li>
<li><a href="https://developer.chrome.com/extensions/messaging" target="_blank" rel="external">Message Passing - Google Chrome</a></li>
<li><a href="https://stackoverflow.com/questions/15718066/chrome-runtime-sendmessage-not-working-as-expected/15718294#15718294" target="_blank" rel="external">chromium - chrome.runtime.sendMessage not working as expected</a></li>
<li><a href="https://codereview.chromium.org/9965005/#ps3001" target="_blank" rel="external">Issue 9965005: Deprecate chrome.extension.sendRequest in favor of sendMessage, with a safer - Code Review</a></li>
<li><a href="http://www.cnblogs.com/champagne/p/4848520.html" target="_blank" rel="external">Chrome浏览器扩展开发系列之十三：消息传递Message</a></li>
</ul>

      
    </div>
    
  </div>
  
  
    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
       支持一杯咖啡吧！
        </span>
      </div>  
  <div id="donate_guide" class="donate_bar center hidden" >
    <!-- 支付宝打赏图案 -->
    <img src="/img/alipay.gif" alt="支付宝打赏"> 
    <!-- 微信打赏图案 -->
    <img src="/img/weixin.gif" alt="微信打赏">  
    </div>
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function(){
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }
  </script>
</div>
<! -- 添加捐赠图标 -->
  

  
    
<nav id="article-nav">
  
    <a href="/2018/05/31/alfred/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Alfred神器使用手册
        
      </div>
    </a>
  
  
    <a href="/2017/09/30/tmux/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Tmux使用手册</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>










  <style>
/*
    Name:     Kimbie (light)
    Author:   Jan T. Sott
    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License
    URL:      https://github.com/idleberg/Kimbie-highlight.js
*/

/* Kimbie Comment */
.hljs-comment,
.hljs-quote {
  color: #a57a4c;
}

/* Kimbie Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-meta {
  color: #dc3958;
}

/* Kimbie Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion,
.hljs-link {
  color: #f79a32;
}

/* Kimbie Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #f06431;
}

/* Kimbie Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #889b4a;
}

/* Kimbie Purple */
.hljs-keyword,
.hljs-selector-tag,
.hljs-function {
  color: #98676a;
}

.hljs {
  display: block;
  overflow-x: auto;
  /*background: #fbebd4;*/
  color: #84613d;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    // hljs.initHighlightingOnLoad();
    [].slice.call(document.querySelectorAll('pre code')).forEach(function(block, i) {
      hljs.highlightBlock(block);
      var lines = block.innerText.split('\n').length - 1;
      var ul = document.createElement('ul');
      ul.className = 'pre-numbering';
      block.className += ' has-numbering';
      block.parentNode.appendChild(ul);
      for(i=1;i<=lines;i++){
        var li = document.createElement('li');
        li.innerText = i;
        ul.appendChild(li);
      }
    });
  </script>
</div>
        <link rel="stylesheet" href="/css/content.css" type="text/css">
<footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <img src="/img/top_arrow.png" class="top_arrow" id="top_arrow">
    	<div class="footer-left">
    		&copy; 2020 路易斯

        <span style="position:relative;top:2px" id="cnzz_stat_icon_1256923583"></span>
        <script type="text/javascript">
          var s = document.createElement('script');
          var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
          s.src = cnzz_protocol + "s11.cnzz.com/z_stat.php?id=1256923583&show=pic";
          document.body.appendChild(s);
        </script>

    	</div>
      	<div class="footer-right">
      		<a href="https://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script type="text/javascript">
  //swifty
  /*(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','4AmBuvmx4Cy-3hvyxeh8','2.0.0');*/
</script>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/content.js"></script>







</div>
<script src="/js/screenfull.js"></script>
<a href="https://github.com/Louiszhai" style="position: fixed; top: 0; right: 0; border: 0;z-index:9999"><img
            source="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
            src="/img/fork_me_on_github.png" alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
</body>
</html>